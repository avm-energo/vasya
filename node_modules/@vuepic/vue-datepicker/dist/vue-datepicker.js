import { openBlock as g, createElementBlock as S, createElementVNode as H, defineComponent as Be, ref as V, inject as ve, computed as C, unref as i, renderSlot as W, createCommentVNode as b, normalizeClass as fe, withKeys as de, createBlock as le, withModifiers as Ue, reactive as Wt, onMounted as Oe, normalizeStyle as ft, Fragment as se, createTextVNode as Fe, toDisplayString as ge, renderList as ye, createVNode as je, Transition as yt, withCtx as ae, nextTick as St, onBeforeUpdate as Da, onUnmounted as un, mergeProps as Ae, createSlots as Pe, isRef as tt, normalizeProps as Le, resolveDynamicComponent as Vt, useSlots as dn, withDirectives as $a, guardReactiveProps as nt, vShow as Ma, watch as Mt, getCurrentScope as Sa, onScopeDispose as Aa, toRef as Ct, provide as dt, Teleport as Pa } from "vue";
import { getMonth as me, getYear as ue, isEqual as Yn, setHours as En, setMinutes as Fn, setSeconds as Wn, setMilliseconds as cn, isValid as Bt, setMonth as Ot, setYear as lt, getHours as Re, getMinutes as Ve, getSeconds as Ge, format as $n, isAfter as fn, isBefore as mn, set as Ce, parseISO as Ca, parse as ln, isDate as Ta, add as Kn, sub as _a, startOfWeek as Hn, endOfWeek as Ra, addMonths as vt, getDay as Va, addDays as Dt, subMonths as Et, addYears as Ba, subYears as Oa, getISOWeek as Na, differenceInCalendarDays as Ia, eachDayOfInterval as Mn } from "date-fns";
const st = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, f] of a)
    n[t] = f;
  return n;
}, Ya = {}, Ea = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Fa = /* @__PURE__ */ H("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1), Wa = /* @__PURE__ */ H("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Ka = /* @__PURE__ */ H("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Ha = /* @__PURE__ */ H("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1), Ua = [
  Fa,
  Wa,
  Ka,
  Ha
];
function La(e, a) {
  return g(), S("svg", Ea, Ua);
}
const Kt = /* @__PURE__ */ st(Ya, [["render", La]]), Ga = {}, ja = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, za = /* @__PURE__ */ H("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1), Xa = /* @__PURE__ */ H("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), qa = [
  za,
  Xa
];
function Ja(e, a) {
  return g(), S("svg", ja, qa);
}
const Za = /* @__PURE__ */ st(Ga, [["render", Ja]]), Qa = {}, xa = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, el = /* @__PURE__ */ H("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), tl = [
  el
];
function nl(e, a) {
  return g(), S("svg", xa, tl);
}
const Sn = /* @__PURE__ */ st(Qa, [["render", nl]]), al = {}, ll = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, rl = /* @__PURE__ */ H("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1), sl = [
  rl
];
function ol(e, a) {
  return g(), S("svg", ll, sl);
}
const An = /* @__PURE__ */ st(al, [["render", ol]]), il = {}, ul = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, dl = /* @__PURE__ */ H("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1), cl = /* @__PURE__ */ H("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), fl = [
  dl,
  cl
];
function ml(e, a) {
  return g(), S("svg", ul, fl);
}
const Un = /* @__PURE__ */ st(il, [["render", ml]]), vl = {}, yl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, pl = /* @__PURE__ */ H("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), hl = [
  pl
];
function gl(e, a) {
  return g(), S("svg", yl, hl);
}
const Ln = /* @__PURE__ */ st(vl, [["render", gl]]), kl = {}, wl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, bl = /* @__PURE__ */ H("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Dl = [
  bl
];
function $l(e, a) {
  return g(), S("svg", wl, Dl);
}
const Gn = /* @__PURE__ */ st(kl, [["render", $l]]), Pn = (e, a) => {
  const n = ln(e, a.slice(0, e.length), new Date());
  return Bt(n) && Ta(n) ? n : null;
}, zt = (e, a) => {
  if (typeof a == "string")
    return Pn(e, a);
  if (Array.isArray(a)) {
    let n = null;
    for (let t = 0; t < a.length && (n = Pn(e, a[t]), !n); t++)
      ;
    return n;
  }
  return typeof a == "function" ? a(e) : null;
}, Ye = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = En(a, 0), a = Fn(a, 0), a = Wn(a, 0), a = cn(a, 0), a;
}, rn = (e) => Array.isArray(e) ? Bt(e[0]) && (e[1] ? Bt(e[1]) : !0) : e ? Bt(e) : !1, Se = (e, a, n, t) => {
  let f = e ? new Date(e) : new Date();
  return (a || a === 0) && (f = En(f, +a)), (n || n === 0) && (f = Fn(f, +n)), (t || t === 0) && (f = Wn(f, +t)), cn(f, 0);
}, Ml = (e) => {
  const a = vt(e, 1);
  return { month: me(a), year: ue(a) };
}, rt = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = Ot(t, a)), n && (t = lt(t, n)), t;
}, Cn = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`, jn = (e, a, n, t, f, m, v, y) => e || (t ? "MM/yyyy" : f ? Cn(a, n) : m ? "MM/dd/yyyy" : v ? "yyyy" : y ? `MM/dd/yyyy, ${Cn(a, n)}` : "MM/dd/yyyy"), Xt = (e) => {
  const a = e || new Date();
  return {
    hours: Re(a),
    minutes: Ve(a),
    seconds: Ge(a)
  };
}, Nt = (e) => ({ month: me(e), year: ue(e) }), Tn = (e) => Array.isArray(e) ? [Nt(e[0]), e[1] ? Nt(e[1]) : null] : Nt(e), sn = (e) => Array.isArray(e) ? [Xt(e[0]), Xt(e[1])] : Xt(e), qt = (e, a, n) => n ? $n(e, a, { locale: n }) : $n(e, a), mt = (e, a, n, t, f) => Array.isArray(e) ? `${qt(e[0], a, n)} ${f && !e[1] ? "" : t || "-"} ${e[1] ? qt(e[1], a, n) : ""}` : qt(e, a, n), $e = (e, a) => !e || !a ? !1 : fn(Ye(e), Ye(a)), we = (e, a) => !e || !a ? !1 : mn(Ye(e), Ye(a)), ie = (e, a) => !e || !a ? !1 : Yn(Ye(e), Ye(a)), Sl = (e, a) => Kn(Ce(new Date(), e), a), Al = (e, a) => _a(Ce(new Date(), e), a), Jt = (e) => Ce(new Date(), { hours: Re(e), minutes: Ve(e), seconds: Ge(e) }), _n = (e) => Ce(new Date(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), ct = (e, a, n, t) => {
  if (!e)
    return !0;
  if (t) {
    const f = n === "max" ? mn(e, a) : fn(e, a), m = { seconds: 0, milliseconds: 0 };
    return f || Yn(Ce(e, m), Ce(a, m));
  }
  return n === "max" ? e.getTime() <= a.getTime() : e.getTime() >= a.getTime();
}, on = (e, a, n, t, f) => {
  let m = !0;
  if (!e)
    return !0;
  const v = !f && !t ? Array.isArray(e) ? [e[0] ? Jt(e[0]) : null, e[1] ? Jt(e[1]) : null] : Jt(e) : e;
  if (a || t) {
    const y = a ? _n(a) : new Date(t);
    Array.isArray(v) ? m = ct(v[0], y, "max", !!t) && ct(v[1], y, "max", !!t) : m = ct(v, y, "max", !!t);
  }
  if (n || f) {
    const y = n ? _n(n) : new Date(f);
    Array.isArray(v) ? m = ct(v[0], y, "min", !!f) && ct(v[1], y, "min", !!f) && m : m = ct(v, y, "min", !!f) && m;
  }
  return m;
}, Pl = (e, a, n) => {
  let t = !0;
  return a && n && (t = $e(new Date(e), new Date(a)) && we(new Date(e), new Date(n))), a && (t = $e(new Date(e), new Date(a))), n && (t = we(new Date(e), new Date(n))), t;
}, Ie = (e) => e instanceof Date ? e : Ca(e), Zt = (e, a) => {
  if (a) {
    const t = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - t).toISOString();
  }
  const n = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(n).toISOString();
}, zn = (e, a, n) => e && e[0] && e[1] ? $e(n, e[0]) && we(n, e[1]) : e && e[0] && a ? $e(n, e[0]) && we(n, a) || we(n, e[0]) && $e(n, a) : !1, Tt = (e, a) => {
  const n = Hn(e, { weekStartsOn: a }), t = Ra(e, { weekStartsOn: a });
  return [n, t];
}, Xn = (e, a) => Array.isArray(a) ? a.some((n) => ie(Ie(new Date(n)), Ie(e))) : a(e), Cl = (e, a, n, t, f, m, v, y) => {
  const h = n ? $e(Ie(e), Ie(n)) : !1, M = a ? we(Ie(e), Ie(a)) : !1, R = Xn(e, t), Y = (m.months.length ? m.months.map((l) => +l) : []).includes(me(e)), O = v.length ? v.some((l) => +l === Va(e)) : !1, L = f.length ? !f.some((l) => ie(Ie(l), Ie(e))) : !1, T = ue(e), te = T < +y[0] || T > +y[1];
  return !(h || M || R || Y || te || O || L);
}, qn = (e, a, n, t, f, m, v) => ({
  validate: (h) => Cl(h, e, a, n, t, f, m, v)
}), ze = Symbol(), Ht = Symbol(), vn = Symbol(), Jn = Symbol(), Zn = Symbol(), Xe = Symbol(), yn = {
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  autoApply: { type: Boolean, default: !1 },
  inline: { type: Boolean, default: !1 },
  textInput: { type: Boolean, default: !1 }
}, pn = {
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null }
}, Qn = {
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 }
}, xn = {
  ...Qn,
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 }
}, ea = {
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: !1 },
  textInputOptions: { type: Object, default: () => null }
}, ta = {
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null }
}, hn = {
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null }
}, na = {
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  ...ta
}, gn = {
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 }
}, aa = {
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: !1 },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: !1 },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  }
}, la = {
  ...xn,
  ...na,
  ...gn,
  ...hn,
  ...aa,
  ...pn,
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: !1 },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: !1 },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  keepActionRow: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  multiStatic: { type: Boolean, default: !0 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  teleportCenter: { type: Boolean, default: !1 }
}, Tl = {
  ...ea,
  ...yn,
  ...la,
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: !1 },
  autoPosition: { type: Boolean, default: !0 },
  closeOnAutoApply: { type: Boolean, default: !0 },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: !1 },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 }
}, ra = {
  range: { type: Boolean, default: !1 },
  multiCalendars: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null }
}, sa = {
  ...gn,
  ...ra,
  vertical: { type: Boolean, default: !1 },
  month: { type: Number, default: 0 },
  year: { type: Number, default: 0 },
  instance: { type: Number, default: 1 }
}, _l = ["aria-label", "aria-disabled", "aria-readonly"], Rl = {
  key: 1,
  class: "dp__input_wrap"
}, Vl = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"], Bl = {
  key: 2,
  class: "dp__input_icon"
}, Ol = {
  key: 4,
  class: "dp__clear_icon"
}, Nl = /* @__PURE__ */ Be({
  __name: "DatepickerInput",
  props: {
    ...ea,
    ...yn,
    ...pn,
    inputValue: { type: String, default: "" },
    inline: { type: Boolean, default: !1 },
    isMenuOpen: { type: Boolean, default: !1 },
    pattern: { type: String, default: "" }
  },
  emits: [
    "clear",
    "open",
    "update:inputValue",
    "setInputDate",
    "close",
    "selectDate",
    "setEmptyDate",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, f = V(), m = V(null), v = V(!1), y = ve(ze), h = C(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !t.textInput,
        dp__disabled: t.disabled,
        dp__input_readonly: !t.textInput,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: v.value || t.isMenuOpen,
        dp__input_reg: !t.textInput,
        [t.inputClassName]: !!t.inputClassName
      })
    ), M = (o) => {
      var U;
      const { value: F } = o.target, { format: J, rangeSeparator: _ } = t.textInputOptions;
      if (F !== "") {
        if (((U = t.textInputOptions) == null ? void 0 : U.openMenu) && !t.isMenuOpen && n("open"), t.range) {
          const [X, Z] = F.split(`${_}`);
          if (X && Z) {
            const Q = zt(X.trim(), J || t.pattern), j = zt(Z.trim(), J || t.pattern);
            f.value = Q && j ? [Q, j] : null;
          }
        } else
          f.value = zt(F, J || t.pattern);
        n("setInputDate", f.value);
      } else
        n("setInputDate", null), t.autoApply && (n("setEmptyDate"), f.value = null);
      n("update:inputValue", F);
    }, R = () => {
      var o, F;
      ((o = t.textInputOptions) == null ? void 0 : o.enterSubmit) && rn(f.value) && t.inputValue !== "" ? (n("setInputDate", f.value, !0), f.value = null) : ((F = t.textInputOptions) == null ? void 0 : F.enterSubmit) && t.inputValue === "" && (f.value = null, n("clear"));
    }, B = () => {
      var o, F;
      ((o = t.textInputOptions) == null ? void 0 : o.tabSubmit) && rn(f.value) && t.inputValue !== "" ? (n("setInputDate", f.value, !0), f.value = null) : ((F = t.textInputOptions) == null ? void 0 : F.tabSubmit) && t.inputValue === "" && (f.value = null, n("clear"));
    }, Y = () => {
      v.value = !0, n("focus");
    }, O = (o) => {
      var F;
      o.preventDefault(), o.stopImmediatePropagation(), o.stopPropagation(), t.textInput && ((F = t.textInputOptions) == null ? void 0 : F.openMenu) ? t.isMenuOpen ? t.textInputOptions.enterSubmit && n("selectDate") : n("open") : t.textInput || n("toggle");
    }, L = () => {
      v.value = !1, t.isMenuOpen || n("blur"), t.autoApply && t.textInput && f.value && (n("setInputDate", f.value), n("selectDate"), f.value = null);
    }, T = () => {
      n("clear");
    }, te = (o) => {
      t.textInput || o.preventDefault();
    };
    return a({
      focusInput: () => {
        m.value && m.value.focus({ preventScroll: !0 });
      }
    }), (o, F) => (g(), S("div", {
      onClick: O,
      "aria-label": i(y).input,
      role: "textbox",
      "aria-multiline": "false",
      "aria-disabled": o.disabled,
      "aria-readonly": o.readonly
    }, [
      o.$slots.trigger && !o.$slots["dp-input"] && !e.inline ? W(o.$slots, "trigger", { key: 0 }) : b("", !0),
      !o.$slots.trigger && (!e.inline || o.inlineWithInput) ? (g(), S("div", Rl, [
        o.$slots["dp-input"] && !o.$slots.trigger && !e.inline ? W(o.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          onInput: M,
          onEnter: R,
          onTab: B,
          onClear: T
        }) : b("", !0),
        o.$slots["dp-input"] ? b("", !0) : (g(), S("input", {
          key: 1,
          ref_key: "inputRef",
          ref: m,
          id: o.uid ? `dp-input-${o.uid}` : void 0,
          name: o.name,
          class: fe(i(h)),
          placeholder: o.placeholder,
          disabled: o.disabled,
          readonly: o.readonly,
          required: o.required,
          value: e.inputValue,
          autocomplete: o.autocomplete,
          onInput: M,
          onKeydown: [
            de(O, ["enter"]),
            de(B, ["tab"])
          ],
          onBlur: L,
          onFocus: Y,
          onKeypress: te
        }, null, 42, Vl)),
        o.$slots["input-icon"] && !o.hideInputIcon ? (g(), S("span", Bl, [
          W(o.$slots, "input-icon")
        ])) : b("", !0),
        !o.$slots["input-icon"] && !o.hideInputIcon && !o.$slots["dp-input"] ? (g(), le(i(Kt), {
          key: 3,
          class: "dp__input_icon dp__input_icons"
        })) : b("", !0),
        o.$slots["clear-icon"] && e.inputValue && o.clearable && !o.disabled && !o.readonly ? (g(), S("span", Ol, [
          W(o.$slots, "clear-icon", { clear: T })
        ])) : b("", !0),
        o.clearable && !o.$slots["clear-icon"] && e.inputValue && !o.disabled && !o.readonly ? (g(), le(i(Za), {
          key: 5,
          class: "dp__clear_icon dp__input_icons",
          onClick: Ue(T, ["stop", "prevent"])
        }, null, 8, ["onClick"])) : b("", !0)
      ])) : b("", !0)
    ], 8, _l));
  }
}), Il = (e) => typeof e == "object", Rn = (e, a) => a, Yl = (e) => Array.isArray(e) && e.length === 2, El = (e) => Array.isArray(e), Fl = (e) => typeof e == "object", bt = (e) => Array.isArray(e), _e = (e) => Array.isArray(e), It = (e) => Array.isArray(e) && e.length === 2, Wl = (e, a) => a ? Array.isArray(e) : It(e), Kl = (e) => Array.isArray(e), Hl = (e) => typeof e == "string" || typeof e == "object" || typeof e == "number", Vn = (e) => typeof e == "string", oe = Wt({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Qt = V(null), _t = V(!1), xt = V(!1), en = V(!1), tn = V(!1), De = V(0), he = V(0), qe = () => {
  const e = C(() => _t.value ? [...oe.selectionGrid, oe.actionRow].filter((l) => l.length) : xt.value ? [
    ...oe.timePicker[0],
    ...oe.timePicker[1],
    tn.value ? [] : [Qt.value],
    oe.actionRow
  ].filter((l) => l.length) : en.value ? [...oe.monthPicker, oe.actionRow] : [oe.monthYear, ...oe.calendar, oe.time, oe.actionRow].filter((l) => l.length)), a = (l) => {
    De.value = l ? De.value + 1 : De.value - 1;
    let o = null;
    e.value[he.value] && (o = e.value[he.value][De.value]), o || (De.value = l ? De.value - 1 : De.value + 1);
  }, n = (l) => {
    if (he.value === 0 && !l || he.value === e.value.length && l)
      return;
    he.value = l ? he.value + 1 : he.value - 1, e.value[he.value] ? e.value[he.value] && !e.value[he.value][De.value] && De.value !== 0 && (De.value = e.value[he.value].length - 1) : he.value = l ? he.value - 1 : he.value + 1;
  }, t = (l) => {
    let o = null;
    e.value[he.value] && (o = e.value[he.value][De.value]), o ? o.focus({ preventScroll: !_t.value }) : De.value = l ? De.value - 1 : De.value + 1;
  }, f = () => {
    a(!0), t(!0);
  }, m = () => {
    a(!1), t(!1);
  }, v = () => {
    n(!1), t(!0);
  }, y = () => {
    n(!0), t(!0);
  }, h = (l, o) => {
    oe[o] = l;
  }, M = (l, o) => {
    oe[o] = l;
  }, R = () => {
    De.value = 0, he.value = 0;
  };
  return {
    buildMatrix: h,
    buildMultiLevelMatrix: M,
    setTimePickerBackRef: (l) => {
      Qt.value = l;
    },
    setSelectionGrid: (l) => {
      _t.value = l, R(), l || (oe.selectionGrid = []);
    },
    setTimePicker: (l, o = !1) => {
      xt.value = l, tn.value = o, R(), l || (oe.timePicker[0] = [], oe.timePicker[1] = []);
    },
    setTimePickerElements: (l, o = 0) => {
      oe.timePicker[o] = l;
    },
    arrowRight: f,
    arrowLeft: m,
    arrowUp: v,
    arrowDown: y,
    clearArrowNav: () => {
      oe.monthYear = [], oe.calendar = [], oe.time = [], oe.actionRow = [], oe.selectionGrid = [], oe.timePicker[0] = [], oe.timePicker[1] = [], _t.value = !1, xt.value = !1, tn.value = !1, en.value = !1, R(), Qt.value = null;
    },
    setMonthPicker: (l) => {
      en.value = l, R();
    }
  };
}, Ul = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), f = [];
  for (let m = 0; m < 7; m++) {
    const v = Dt(t, m), y = me(v) !== a;
    f.push({
      text: n && y ? "" : v.getDate(),
      value: v,
      current: !y
    });
  }
  return f;
}, Ll = (e, a, n, t) => {
  const f = [], m = new Date(a, e), v = new Date(a, e + 1, 0), y = Hn(m, { weekStartsOn: n }), h = (M) => {
    const R = Ul(M, e, t);
    if (f.push({ days: R }), !f[f.length - 1].days.some((B) => ie(Ye(B.value), Ye(v)))) {
      const B = Dt(M, 7);
      h(B);
    }
  };
  return h(y), f;
}, Gl = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
}, jl = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((m) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${m}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), f = n.slice(a + 1, n.length);
  return [n[a]].concat(...f).concat(...t);
}, zl = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
}, Xl = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((f) => {
    const m = f < 10 ? `0${f}` : f;
    return new Date(`2017-${m}-01T00:00:00+00:00`);
  }).map((f, m) => ({
    text: n.format(f),
    value: m
  }));
}, ql = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Jl = () => ({
  enterSubmit: !0,
  tabSubmit: !0,
  openMenu: !0,
  rangeSeparator: " - "
}), Zl = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e), Ql = (e) => {
  function n(t) {
    let f = "";
    const m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", v = m.length;
    for (let y = 0; y < t; y++)
      f += m.charAt(Math.floor(Math.random() * v));
    return f + e;
  }
  return n(5);
}, ke = (e) => {
  var n;
  const a = i(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
}, xl = (e) => Object.assign({ type: "dot" }, e), Bn = (e) => Object.assign(
  {
    menuAppear: "dp-menu-appear",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  },
  e
), er = (e) => Object.assign(
  {
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (a) => `Increment ${a}`,
    decrementValue: (a) => `Decrement ${a}`,
    openTpOverlay: (a) => `Open ${a} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month"
  },
  e
), oa = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, tr = { class: "dp__selection_preview" }, nr = { class: "dp__action_buttons" }, ar = ["onKeydown"], lr = /* @__PURE__ */ Be({
  __name: "ActionRow",
  props: {
    ...na,
    ...hn,
    ...ta,
    ...gn,
    ...ra,
    inline: { type: Boolean, default: !1 },
    timePicker: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: !1 },
    enableTimePicker: { type: Boolean, default: !0 }
  },
  emits: ["closePicker", "selectDate", "invalid-select"],
  setup(e, { emit: a }) {
    const n = e, { buildMatrix: t } = qe(), f = ve(Zn), m = ve(Xe), v = V(null), y = V(null);
    Oe(() => {
      m != null && m.value && t([ke(v), ke(y)], "actionRow");
    });
    const h = C(() => n.range && !n.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : !0), M = C(() => ({
      dp__action: !0,
      dp__select: !0,
      dp__action_disabled: !R.value || !B.value || !h.value
    })), R = C(() => !n.enableTimePicker || n.ignoreTimeValidation ? !0 : on(n.internalModelValue, n.maxTime, n.minTime, n.maxDate, n.minDate)), B = C(() => n.monthPicker ? Pl(n.internalModelValue, n.minDate, n.maxDate) : !0), Y = (T) => mt(T, n.previewFormat, f == null ? void 0 : f.value), O = C(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? bt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${Y(n.internalModelValue[0])} - ${Y(
      n.internalModelValue[1]
    )}` : [Y(n.internalModelValue[0]), Y(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((T) => `${Y(T)}`) : n.modelAuto ? `${Y(n.internalModelValue[0])}` : `${Y(n.internalModelValue[0])} -` : mt(n.internalModelValue, n.previewFormat, f == null ? void 0 : f.value) : n.timePicker ? n.previewFormat(sn(n.internalModelValue)) : n.monthPicker ? n.previewFormat(Nt(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), L = () => {
      R.value && B.value && h.value ? a("selectDate") : a("invalid-select");
    };
    return (T, te) => (g(), S("div", {
      class: "dp__action_row",
      style: ft(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      H("div", tr, [
        T.$slots["action-preview"] ? W(T.$slots, "action-preview", {
          key: 0,
          value: T.internalModelValue
        }) : b("", !0),
        T.$slots["action-preview"] ? b("", !0) : (g(), S(se, { key: 1 }, [
          Array.isArray(i(O)) ? b("", !0) : (g(), S(se, { key: 0 }, [
            Fe(ge(i(O)), 1)
          ], 64)),
          Array.isArray(i(O)) ? (g(!0), S(se, { key: 1 }, ye(i(O), (l, o) => (g(), S("div", { key: o }, ge(l), 1))), 128)) : b("", !0)
        ], 64))
      ]),
      H("div", nr, [
        T.$slots["action-select"] ? W(T.$slots, "action-select", {
          key: 0,
          value: T.internalModelValue
        }) : b("", !0),
        T.$slots["action-select"] ? b("", !0) : (g(), S(se, { key: 1 }, [
          e.inline ? b("", !0) : (g(), S("span", {
            key: 0,
            class: "dp__action dp__cancel",
            ref_key: "cancelButtonRef",
            ref: v,
            tabindex: "0",
            onClick: te[0] || (te[0] = (l) => T.$emit("closePicker")),
            onKeydown: te[1] || (te[1] = de((l) => T.$emit("closePicker"), ["enter"]))
          }, ge(T.cancelText), 545)),
          H("span", {
            class: fe(i(M)),
            tabindex: "0",
            onKeydown: de(L, ["enter"]),
            onClick: L,
            ref_key: "selectButtonRef",
            ref: y
          }, ge(T.selectText), 43, ar)
        ], 64))
      ])
    ], 4));
  }
}), rr = ["aria-label"], sr = {
  class: "dp__calendar_header",
  role: "row"
}, or = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, ir = /* @__PURE__ */ H("div", { class: "dp__calendar_header_separator" }, null, -1), ur = ["aria-label"], dr = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, cr = { class: "dp__cell_inner" }, fr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], mr = /* @__PURE__ */ H("div", { class: "dp__arrow_bottom_tp" }, null, -1), vr = /* @__PURE__ */ Be({
  __name: "Calendar",
  props: {
    ...sa,
    ...aa,
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    modeHeight: { type: [Number, String], default: 255 },
    specificMode: { type: Boolean, default: !1 }
  },
  emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe"],
  setup(e, { expose: a, emit: n }) {
    const t = e, f = V(null), m = V({ bottom: "", left: "", transform: "" }), v = V([]), y = V(null), h = V(!0), M = ve(Ht), R = ve(ze), B = ve(Xe), Y = V(""), O = V({ startX: 0, endX: 0, startY: 0, endY: 0 }), L = C(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : jl(t.locale, +t.weekStart)), { buildMultiLevelMatrix: T } = qe();
    Oe(() => {
      n("mount", { cmp: "calendar", refs: v }), t.noSwipe || y.value && (y.value.addEventListener("touchstart", Z, { passive: !1 }), y.value.addEventListener("touchend", Q, { passive: !1 }), y.value.addEventListener("touchmove", j, { passive: !1 })), t.monthChangeOnScroll && y.value && y.value.addEventListener("wheel", u, { passive: !1 });
    });
    const te = (s, k) => {
      if (M != null && M.value) {
        const E = Ye(rt(new Date(), t.month, t.year));
        Y.value = $e(Ye(rt(new Date(), s, k)), E) ? M.value[t.vertical ? "vNext" : "next"] : M.value[t.vertical ? "vPrevious" : "previous"], h.value = !1, St(() => {
          h.value = !0;
        });
      }
    }, l = C(
      () => ({
        dp__calendar_wrap: !0,
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), o = C(() => (s) => {
      const k = xl(s);
      return {
        dp__marker_dot: k.type === "dot",
        dp__marker_line: k.type === "line"
      };
    }), F = C(() => (s) => ie(s, f.value)), J = C(() => ({
      dp__calendar: !0,
      dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0
    })), _ = C(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), U = (s, k, E) => {
      var ee, I;
      if (n("setHoverDate", s), (I = (ee = s.marker) == null ? void 0 : ee.tooltip) != null && I.length) {
        const re = ke(v.value[k][E]);
        if (re) {
          const { width: p, height: P } = re.getBoundingClientRect();
          m.value = {
            bottom: `${P}px`,
            left: `${p / 2}px`,
            transform: "translateX(-50%)"
          }, f.value = s.value;
        }
      }
    }, X = () => {
      f.value = null;
    }, Z = (s) => {
      O.value.startX = s.changedTouches[0].screenX, O.value.startY = s.changedTouches[0].screenY;
    }, Q = (s) => {
      O.value.endX = s.changedTouches[0].screenX, O.value.endY = s.changedTouches[0].screenY, $();
    }, j = (s) => {
      s.preventDefault();
    }, $ = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(O.value[`start${s}`] - O.value[`end${s}`]) > 10 && n("handleSwipe", O.value[`start${s}`] > O.value[`end${s}`] ? "right" : "left");
    }, D = (s, k, E) => {
      s && (Array.isArray(v.value[k]) ? v.value[k][E] = s : v.value[k] = [s]), B != null && B.value && T(v.value, "calendar");
    }, u = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), n("handleScroll", s));
    };
    return a({ triggerTransition: te }), (s, k) => (g(), S("div", {
      class: fe(i(J))
    }, [
      H("div", {
        style: ft(i(_))
      }, [
        e.specificMode ? b("", !0) : (g(), S("div", {
          key: 0,
          ref_key: "calendarWrapRef",
          ref: y,
          class: fe(i(l)),
          role: "grid",
          "aria-label": i(R).calendarWrap
        }, [
          H("div", sr, [
            s.weekNumbers ? (g(), S("div", or, ge(s.weekNumName), 1)) : b("", !0),
            (g(!0), S(se, null, ye(i(L), (E, ee) => (g(), S("div", {
              class: "dp__calendar_header_item",
              role: "gridcell",
              key: ee
            }, [
              s.$slots["calendar-header"] ? W(s.$slots, "calendar-header", {
                key: 0,
                day: E,
                index: ee
              }) : b("", !0),
              s.$slots["calendar-header"] ? b("", !0) : (g(), S(se, { key: 1 }, [
                Fe(ge(E), 1)
              ], 64))
            ]))), 128))
          ]),
          ir,
          je(yt, {
            name: Y.value,
            css: !!i(M)
          }, {
            default: ae(() => [
              h.value ? (g(), S("div", {
                key: 0,
                class: "dp__calendar",
                role: "grid",
                "aria-label": i(R).calendarDays
              }, [
                (g(!0), S(se, null, ye(e.mappedDates, (E, ee) => (g(), S("div", {
                  class: "dp__calendar_row",
                  role: "row",
                  key: ee
                }, [
                  s.weekNumbers ? (g(), S("div", dr, [
                    H("div", cr, ge(e.getWeekNum(E.days)), 1)
                  ])) : b("", !0),
                  (g(!0), S(se, null, ye(E.days, (I, re) => (g(), S("div", {
                    role: "gridcell",
                    class: "dp__calendar_item",
                    ref_for: !0,
                    ref: (p) => D(p, ee, re),
                    key: re + ee,
                    "aria-selected": I.classData.dp__active_date || I.classData.dp__range_start || I.classData.dp__range_start,
                    "aria-disabled": I.classData.dp__cell_disabled,
                    tabindex: "0",
                    onClick: Ue((p) => s.$emit("selectDate", I), ["stop", "prevent"]),
                    onKeydown: de((p) => s.$emit("selectDate", I), ["enter"]),
                    onMouseover: (p) => U(I, ee, re),
                    onMouseleave: X
                  }, [
                    H("div", {
                      class: fe(["dp__cell_inner", I.classData])
                    }, [
                      s.$slots.day ? W(s.$slots, "day", {
                        key: 0,
                        day: +I.text,
                        date: I.value
                      }) : b("", !0),
                      s.$slots.day ? b("", !0) : (g(), S(se, { key: 1 }, [
                        Fe(ge(I.text), 1)
                      ], 64)),
                      I.marker ? (g(), S("div", {
                        key: 2,
                        class: fe(i(o)(I.marker)),
                        style: ft(I.marker.color ? { backgroundColor: I.marker.color } : {})
                      }, null, 6)) : b("", !0),
                      i(F)(I.value) ? (g(), S("div", {
                        key: 3,
                        class: "dp__marker_tooltip",
                        style: ft(m.value)
                      }, [
                        H("div", {
                          class: "dp__tooltip_content",
                          onClick: k[0] || (k[0] = Ue(() => {
                          }, ["stop"]))
                        }, [
                          (g(!0), S(se, null, ye(I.marker.tooltip, (p, P) => (g(), S("div", {
                            key: P,
                            class: "dp__tooltip_text"
                          }, [
                            s.$slots["marker-tooltip"] ? W(s.$slots, "marker-tooltip", {
                              key: 0,
                              tooltop: p,
                              day: I.value
                            }) : b("", !0),
                            s.$slots["marker-tooltip"] ? b("", !0) : (g(), S(se, { key: 1 }, [
                              H("div", {
                                class: "dp__tooltip_mark",
                                style: ft(p.color ? { backgroundColor: p.color } : {})
                              }, null, 4),
                              H("div", null, ge(p.text), 1)
                            ], 64))
                          ]))), 128)),
                          mr
                        ])
                      ], 4)) : b("", !0)
                    ], 2)
                  ], 40, fr))), 128))
                ]))), 128))
              ], 8, ur)) : b("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 10, rr))
      ], 4)
    ], 2));
  }
}), yr = ["aria-label"], nn = /* @__PURE__ */ Be({
  __name: "ActionIcon",
  props: { ariaLabel: { type: String, default: "" } },
  emits: ["activate", "setRef"],
  setup(e, { emit: a }) {
    const n = V(null);
    return Oe(() => a("setRef", n)), (t, f) => (g(), S("div", {
      class: "dp__month_year_col_nav",
      onClick: f[0] || (f[0] = (m) => t.$emit("activate")),
      onKeydown: f[1] || (f[1] = de((m) => t.$emit("activate"), ["enter"])),
      tabindex: "0",
      ref_key: "elRef",
      ref: n
    }, [
      H("div", {
        class: "dp__inner_nav",
        role: "button",
        "aria-label": e.ariaLabel
      }, [
        W(t.$slots, "default")
      ], 8, yr)
    ], 544));
  }
}), pr = { class: "dp__selection_grid_header" }, hr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], gr = ["aria-label", "onKeydown"], $t = /* @__PURE__ */ Be({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: !1 },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: !1 },
    monthPicker: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "selected", "toggle", "reset-flow"],
  setup(e, { expose: a, emit: n }) {
    const t = e, f = V(!1), m = V(null), v = V(null), y = V([]), h = ve(vn, !1), M = ve(Jn, V(!1)), R = ve(ze), B = ve(Xe), Y = V(), O = V(), { setSelectionGrid: L, buildMultiLevelMatrix: T, setMonthPicker: te } = qe();
    Da(() => {
      m.value = null;
    }), Oe(() => {
      St().then(() => Q()), o(), l(!0);
    }), un(() => l(!1));
    const l = (s) => {
      var k;
      B != null && B.value && ((k = t.headerRefs) != null && k.length ? te(s) : L(s));
    }, o = () => {
      const s = ke(v);
      s && (M.value || s.focus({ preventScroll: !0 }), f.value = s.clientHeight < s.scrollHeight);
    }, F = C(
      () => ({
        dp__overlay: !0
      })
    ), J = C(() => ({
      dp__overlay_col: !0
    })), _ = C(() => t.items.map((s) => s.filter((k) => k).map((k) => {
      var I, re, p;
      const E = t.disabledValues.some((P) => P === k.value) || Z(k.value), ee = (I = t.multiModelValue) != null && I.length ? (re = t.multiModelValue) == null ? void 0 : re.some(
        (P) => ie(
          P,
          lt(
            t.monthPicker ? Ot(new Date(), k.value) : new Date(),
            t.monthPicker ? t.year : k.value
          )
        )
      ) : t.skipActive ? !1 : k.value === t.modelValue;
      return {
        ...k,
        className: {
          dp__overlay_cell_active: ee,
          dp__overlay_cell: !ee,
          dp__overlay_cell_disabled: E,
          dp__overlay_cell_active_disabled: E && ee,
          dp__overlay_cell_pad: !0,
          dp__cell_in_between: (p = t.multiModelValue) != null && p.length ? $(k.value) : !1
        }
      };
    }))), U = C(
      () => ({
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: f.value,
        dp__button_bottom: h
      })
    ), X = C(() => {
      var s, k;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((s = t.items) == null ? void 0 : s.length) <= 6,
        dp__container_block: ((k = t.items) == null ? void 0 : k.length) > 6
      };
    }), Z = (s) => {
      const k = t.maxValue || t.maxValue === 0, E = t.minValue || t.minValue === 0;
      return !k && !E ? !1 : k && E ? +s > +t.maxValue || +s < +t.minValue : k ? +s > +t.maxValue : E ? +s < +t.minValue : !1;
    }, Q = () => {
      const s = ke(m);
      if (s) {
        const k = ke(v);
        k && (k.scrollTop = s.offsetTop - k.offsetTop - (k.getBoundingClientRect().height / 2 - s.getBoundingClientRect().height));
      }
    }, j = (s) => {
      !t.disabledValues.some((k) => k === s) && !Z(s) && (n("update:modelValue", s), n("selected"));
    }, $ = (s) => {
      const k = t.monthPicker ? t.year : s;
      return zn(
        t.multiModelValue,
        lt(
          t.monthPicker ? Ot(new Date(), Y.value || 0) : new Date(),
          t.monthPicker ? k : Y.value || k
        ),
        lt(t.monthPicker ? Ot(new Date(), s) : new Date(), k)
      );
    }, D = () => {
      n("toggle"), n("reset-flow");
    }, u = (s, k, E, ee) => {
      var I, re;
      if (s && (k.value === +t.modelValue && !t.disabledValues.includes(k.value) && (m.value = s), B != null && B.value)) {
        Array.isArray(y.value[E]) ? y.value[E][ee] = s : y.value[E] = [s];
        const p = (I = t.headerRefs) != null && I.length ? [t.headerRefs].concat(y.value) : y.value.concat([t.skipButtonRef ? [] : [O.value]]);
        T(p, (re = t.headerRefs) != null && re.length ? "monthPicker" : "selectionGrid");
      }
    };
    return a({ focusGrid: o }), (s, k) => (g(), S("div", {
      ref_key: "gridWrapRef",
      ref: v,
      class: fe(i(F)),
      role: "dialog",
      tabindex: "0"
    }, [
      H("div", {
        class: fe(i(X)),
        role: "grid"
      }, [
        H("div", pr, [
          W(s.$slots, "header")
        ]),
        (g(!0), S(se, null, ye(i(_), (E, ee) => (g(), S("div", {
          class: "dp__overlay_row",
          key: i(Ql)(ee),
          role: "row"
        }, [
          (g(!0), S(se, null, ye(E, (I, re) => (g(), S("div", {
            role: "gridcell",
            class: fe(i(J)),
            key: I.value,
            "aria-selected": I.value === e.modelValue && !e.disabledValues.includes(I.value),
            "aria-disabled": I.className.dp__overlay_cell_disabled,
            ref_for: !0,
            ref: (p) => u(p, I, ee, re),
            tabindex: "0",
            onClick: (p) => j(I.value),
            onKeydown: de((p) => j(I.value), ["enter"]),
            onMouseover: (p) => Y.value = I.value
          }, [
            H("div", {
              class: fe(I.className)
            }, [
              s.$slots.item ? W(s.$slots, "item", {
                key: 0,
                item: I
              }) : b("", !0),
              s.$slots.item ? b("", !0) : (g(), S(se, { key: 1 }, [
                Fe(ge(I.text), 1)
              ], 64))
            ], 2)
          ], 42, hr))), 128))
        ]))), 128)),
        s.$slots["button-icon"] ? (g(), S("div", {
          key: 0,
          role: "button",
          "aria-label": i(R).toggleOverlay,
          class: fe(i(U)),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: O,
          onClick: D,
          onKeydown: de(D, ["enter"])
        }, [
          W(s.$slots, "button-icon")
        ], 42, gr)) : b("", !0)
      ], 2)
    ], 2));
  }
}), Ut = () => {
  const e = ve(Ht);
  return { transitionName: C(() => (n) => e != null && e.value ? n ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
}, kr = ["aria-label"], On = /* @__PURE__ */ Be({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: !1 },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "setRef"],
  setup(e, { emit: a }) {
    const { transitionName: n, showTransition: t } = Ut(), f = V(null);
    return Oe(() => a("setRef", f)), (m, v) => (g(), S(se, null, [
      H("div", {
        class: "dp__month_year_select",
        onClick: v[0] || (v[0] = (y) => m.$emit("toggle")),
        onKeydown: v[1] || (v[1] = de((y) => m.$emit("toggle"), ["enter"])),
        role: "button",
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: f
      }, [
        W(m.$slots, "default")
      ], 40, kr),
      je(yt, {
        name: i(n)(e.showSelectionGrid),
        css: i(t)
      }, {
        default: ae(() => [
          e.showSelectionGrid ? (g(), le($t, Ae({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue
          }, {
            "header-refs": [],
            "onUpdate:modelValue": v[2] || (v[2] = (y) => m.$emit("update:model-value", y)),
            onToggle: v[3] || (v[3] = (y) => m.$emit("toggle"))
          }), Pe({
            "button-icon": ae(() => [
              m.$slots["calendar-icon"] ? W(m.$slots, "calendar-icon", { key: 0 }) : b("", !0),
              m.$slots["calendar-icon"] ? b("", !0) : (g(), le(i(Kt), { key: 1 }))
            ]),
            _: 2
          }, [
            m.$slots[e.slotName] ? {
              name: "item",
              fn: ae(({ item: y }) => [
                W(m.$slots, e.slotName, { item: y })
              ]),
              key: "0"
            } : void 0
          ]), 1040)) : b("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), Ft = (e, a, n) => [Ce(new Date(e), { date: 1 }), Ce(new Date(), { month: a, year: n, date: 1 })], Nn = (e, a, n) => we(...Ft(e, a, n)) || ie(...Ft(e, a, n)), In = (e, a, n) => $e(...Ft(e, a, n)) || ie(...Ft(e, a, n)), ia = (e, a, n, t, f, m) => {
  let v = !1;
  return m ? e && a ? (a && f && In(a, n, t) && (v = !0), e && !f && Nn(e, n, t) && (v = !0)) : (e && Nn(e, n, t) || a && In(a, n, t)) && (v = !0) : v = !0, v;
}, wr = (e, a) => {
  const n = (v, y) => {
    let h = v;
    return e.filters.months.includes(me(h)) ? (h = y ? vt(v, 1) : Et(v, 1), n(h, y)) : h;
  }, t = (v, y) => {
    let h = v;
    return e.filters.years.includes(ue(h)) ? (h = y ? Ba(v, 1) : Oa(v, 1), t(h, y)) : h;
  }, f = (v) => {
    const y = Ce(new Date(), { month: e.month, year: e.year });
    let h = v ? vt(y, 1) : Et(y, 1), M = me(h), R = ue(h);
    e.filters.months.includes(M) && (h = n(h, v), M = me(h), R = ue(h)), e.filters.years.includes(R) && (h = t(h, v), R = ue(h)), ia(e.minDate, e.maxDate, M, R, v, e.preventMinMaxNavigation) && m(M, R);
  }, m = (v, y) => {
    a("update-month-year", { month: v, year: y });
  };
  return { handleMonthYearChange: f };
}, br = { class: "dp__month_year_row" }, Dr = { class: "dp__month_picker_header" }, $r = ["aria-label"], Mr = ["aria-label", "onKeydown"], Sr = ["aria-label"], Ar = /* @__PURE__ */ Be({
  __name: "MonthYearPicker",
  props: {
    ...sa,
    ...hn,
    preventMinMaxNavigation: { type: Boolean, default: !1 },
    reverseYears: { type: Boolean, default: !1 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    filters: { type: Object, default: () => ({}) },
    multiCalendarsSolo: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 }
  },
  emits: ["update-month-year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: a, emit: n }) {
    const t = e, { transitionName: f, showTransition: m } = Ut(), { buildMatrix: v } = qe(), y = V(!1), h = V(!1), M = V([null, null, null, null]), R = V(null), B = V(null), Y = V(null), O = ve(ze), L = ve(Xe), { handleMonthYearChange: T } = wr(t, n);
    Oe(() => {
      n("mount");
    });
    const te = (p) => ({
      get: () => t[p],
      set: (P) => {
        const N = p === "month" ? "year" : "month";
        n("update-month-year", { [p]: P, [N]: t[N] }), n("monthYearSelect", p === "year"), p === "month" ? k(!0) : E(!0);
      }
    }), l = C(te("month")), o = C(te("year")), F = C(() => (p) => {
      const P = p === "month";
      return {
        showSelectionGrid: (P ? y : h).value,
        items: (P ? $ : D).value,
        disabledValues: t.filters[P ? "months" : "years"],
        minValue: (P ? U : J).value,
        maxValue: (P ? X : _).value,
        headerRefs: P && t.monthPicker ? [R.value, B.value, Y.value] : []
      };
    }), J = C(() => t.minDate ? ue(new Date(t.minDate)) : null), _ = C(() => t.maxDate ? ue(new Date(t.maxDate)) : null), U = C(() => {
      if (t.minDate && J.value) {
        if (J.value > t.year)
          return 12;
        if (J.value === t.year)
          return me(new Date(t.minDate));
      }
      return null;
    }), X = C(() => t.maxDate && _.value ? _.value < t.year ? -1 : _.value === t.year ? me(new Date(t.maxDate)) : null : null), Z = C(() => t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), Q = (p, P = !1) => {
      const N = [];
      for (let pe = 0; pe < p.length; pe += 3) {
        const Ee = [p[pe], p[pe + 1], p[pe + 2]];
        N.push(P ? Ee.reverse() : Ee);
      }
      return P ? N.reverse() : N;
    }, j = C(() => {
      const p = t.months.find((P) => P.value === t.month);
      return p || { text: "", value: 0 };
    }), $ = C(() => Q(t.months)), D = C(() => Q(t.years, t.reverseYears)), u = C(() => t.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === 0 : !0), s = C(() => t.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === t.multiCalendars - 1 : !0), k = (p = !1) => {
      ee(p), y.value = !y.value, y.value || n("overlay-closed");
    }, E = (p = !1) => {
      ee(p), h.value = !h.value, h.value || n("overlay-closed");
    }, ee = (p) => {
      p || n("reset-flow");
    }, I = (p = !1) => {
      n("update-month-year", { year: p ? t.year + 1 : t.year - 1, month: t.month });
    }, re = (p, P) => {
      L != null && L.value && (M.value[P] = ke(p), v(M.value, "monthYear"));
    };
    return a({
      toggleMonthPicker: k,
      toggleYearPicker: E
    }), (p, P) => (g(), S("div", br, [
      !p.monthPicker && !e.yearPicker ? (g(), S(se, { key: 0 }, [
        i(u) && !p.vertical ? (g(), le(nn, {
          key: 0,
          "aria-label": i(O).prevMonth,
          onActivate: P[0] || (P[0] = (N) => i(T)(!1)),
          onSetRef: P[1] || (P[1] = (N) => re(N, 0))
        }, {
          default: ae(() => [
            p.$slots["arrow-left"] ? W(p.$slots, "arrow-left", { key: 0 }) : b("", !0),
            p.$slots["arrow-left"] ? b("", !0) : (g(), le(i(Sn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label"])) : b("", !0),
        je(On, Ae({
          "aria-label": i(O).openMonthsOverlay,
          "slot-name": "month-overlay",
          modelValue: i(l),
          "onUpdate:modelValue": P[2] || (P[2] = (N) => tt(l) ? l.value = N : null)
        }, i(F)("month"), {
          onToggle: k,
          onSetRef: P[3] || (P[3] = (N) => re(N, 1))
        }), Pe({
          default: ae(() => [
            p.$slots.month ? W(p.$slots, "month", Le(Ae({ key: 0 }, i(j)))) : b("", !0),
            p.$slots.month ? b("", !0) : (g(), S(se, { key: 1 }, [
              Fe(ge(i(j).text), 1)
            ], 64))
          ]),
          _: 2
        }, [
          p.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: ae(() => [
              W(p.$slots, "calendar-icon")
            ]),
            key: "0"
          } : void 0,
          p.$slots["month-overlay"] ? {
            name: "month-overlay",
            fn: ae(({ item: N }) => [
              W(p.$slots, "month-overlay", {
                text: N.text,
                value: N.value
              })
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        je(On, Ae({
          "aria-label": i(O).openYearsOverlay,
          "slot-name": "year-overlay",
          modelValue: i(o),
          "onUpdate:modelValue": P[4] || (P[4] = (N) => tt(o) ? o.value = N : null)
        }, i(F)("year"), {
          onToggle: E,
          onSetRef: P[5] || (P[5] = (N) => re(N, 2))
        }), Pe({
          default: ae(() => [
            p.$slots.year ? W(p.$slots, "year", {
              key: 0,
              year: p.year
            }) : b("", !0),
            p.$slots.year ? b("", !0) : (g(), S(se, { key: 1 }, [
              Fe(ge(p.year), 1)
            ], 64))
          ]),
          _: 2
        }, [
          p.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: ae(() => [
              W(p.$slots, "calendar-icon")
            ]),
            key: "0"
          } : void 0,
          p.$slots["year-overlay"] ? {
            name: "year-overlay",
            fn: ae(({ item: N }) => [
              W(p.$slots, "year-overlay", {
                text: N.text,
                value: N.value
              })
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        i(u) && p.vertical ? (g(), le(nn, {
          key: 1,
          "aria-label": i(O).prevMonth,
          onActivate: P[6] || (P[6] = (N) => i(T)(!1))
        }, {
          default: ae(() => [
            p.$slots["arrow-up"] ? W(p.$slots, "arrow-up", { key: 0 }) : b("", !0),
            p.$slots["arrow-up"] ? b("", !0) : (g(), le(i(Ln), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label"])) : b("", !0),
        i(s) ? (g(), le(nn, {
          key: 2,
          "arial-label": i(O).nextMonth,
          onActivate: P[7] || (P[7] = (N) => i(T)(!0)),
          ref: "rightIcon",
          onSetRef: P[8] || (P[8] = (N) => re(N, 3))
        }, {
          default: ae(() => [
            p.$slots[p.vertical ? "arrow-down" : "arrow-right"] ? W(p.$slots, p.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : b("", !0),
            p.$slots[p.vertical ? "arrow-down" : "arrow-right"] ? b("", !0) : (g(), le(Vt(p.vertical ? i(Gn) : i(An)), { key: 1 }))
          ]),
          _: 3
        }, 8, ["arial-label"])) : b("", !0)
      ], 64)) : b("", !0),
      p.monthPicker ? (g(), le($t, Ae({ key: 1 }, i(F)("month"), {
        "skip-active": t.range,
        year: p.year,
        "multi-model-value": i(Z),
        "month-picker": "",
        modelValue: i(l),
        "onUpdate:modelValue": P[15] || (P[15] = (N) => tt(l) ? l.value = N : null),
        onToggle: k,
        onSelected: P[16] || (P[16] = (N) => p.$emit("overlay-closed"))
      }), Pe({
        header: ae(() => [
          H("div", Dr, [
            H("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpPrevIconRef",
              ref: R,
              onClick: P[9] || (P[9] = (N) => I(!1)),
              onKeydown: P[10] || (P[10] = de((N) => I(!1), ["enter"]))
            }, [
              H("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": i(O).prevMonth
              }, [
                p.$slots["arrow-left"] ? W(p.$slots, "arrow-left", { key: 0 }) : b("", !0),
                p.$slots["arrow-left"] ? b("", !0) : (g(), le(i(Sn), { key: 1 }))
              ], 8, $r)
            ], 544),
            H("div", {
              class: "dp__pointer",
              role: "button",
              ref_key: "mpYearButtonRef",
              ref: B,
              "aria-label": i(O).openYearsOverlay,
              tabindex: "0",
              onClick: E,
              onKeydown: de(E, ["enter"])
            }, [
              p.$slots.year ? W(p.$slots, "year", {
                key: 0,
                year: p.year
              }) : b("", !0),
              p.$slots.year ? b("", !0) : (g(), S(se, { key: 1 }, [
                Fe(ge(p.year), 1)
              ], 64))
            ], 40, Mr),
            H("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpNextIconRef",
              ref: Y,
              onClick: P[11] || (P[11] = (N) => I(!0)),
              onKeydown: P[12] || (P[12] = de((N) => I(!0), ["enter"]))
            }, [
              H("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": i(O).nextMonth
              }, [
                p.$slots["arrow-right"] ? W(p.$slots, "arrow-right", { key: 0 }) : b("", !0),
                p.$slots["arrow-right"] ? b("", !0) : (g(), le(i(An), { key: 1 }))
              ], 8, Sr)
            ], 544)
          ]),
          je(yt, {
            name: i(f)(h.value),
            css: i(m)
          }, {
            default: ae(() => [
              h.value ? (g(), le($t, Ae({ key: 0 }, i(F)("year"), {
                modelValue: i(o),
                "onUpdate:modelValue": P[13] || (P[13] = (N) => tt(o) ? o.value = N : null),
                onToggle: E,
                onSelected: P[14] || (P[14] = (N) => p.$emit("overlay-closed"))
              }), Pe({
                "button-icon": ae(() => [
                  p.$slots["calendar-icon"] ? W(p.$slots, "calendar-icon", { key: 0 }) : b("", !0),
                  p.$slots["calendar-icon"] ? b("", !0) : (g(), le(i(Kt), { key: 1 }))
                ]),
                _: 2
              }, [
                p.$slots["year-overlay"] ? {
                  name: "item",
                  fn: ae(({ item: N }) => [
                    W(p.$slots, "year-overlay", {
                      text: N.text,
                      value: N.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1040, ["modelValue"])) : b("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 2
      }, [
        p.$slots["month-overlay"] ? {
          name: "item",
          fn: ae(({ item: N }) => [
            W(p.$slots, "month-overlay", {
              text: N.text,
              value: N.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : b("", !0),
      e.yearPicker ? (g(), le($t, Ae({ key: 2 }, i(F)("year"), {
        modelValue: i(o),
        "onUpdate:modelValue": P[17] || (P[17] = (N) => tt(o) ? o.value = N : null),
        "multi-model-value": i(Z),
        "skip-active": t.range,
        "skip-button-ref": "",
        "year-picker": "",
        onToggle: E,
        onSelected: P[18] || (P[18] = (N) => p.$emit("overlay-closed"))
      }), Pe({ _: 2 }, [
        p.$slots["year-overlay"] ? {
          name: "item",
          fn: ae(({ item: N }) => [
            W(p.$slots, "year-overlay", {
              text: N.text,
              value: N.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : b("", !0)
    ]));
  }
}), Pr = {
  key: 0,
  class: "dp__time_input"
}, Cr = /* @__PURE__ */ Fe(" : "), Tr = ["aria-label", "onKeydown", "onClick"], _r = ["aria-label", "onKeydown", "onClick"], Rr = ["aria-label", "onKeydown", "onClick"], Vr = { key: 0 }, Br = ["aria-label", "onKeydown"], Or = /* @__PURE__ */ Be({
  __name: "TimeInput",
  props: {
    ...Qn,
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    filters: { type: Object, default: () => ({}) },
    disabled: { type: Boolean, default: !1 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 }
  },
  emits: [
    "setHours",
    "setMinutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, f = Wt({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), m = V("AM"), v = V(null), y = ve(ze), h = ve(Xe), M = V([]), { transitionName: R, showTransition: B } = Ut(), { setTimePickerElements: Y, setTimePickerBackRef: O } = qe();
    Oe(() => {
      n("mounted");
    });
    const L = C(
      () => ({
        dp__time_col: !0,
        dp__time_col_reg: !t.enableSeconds && t.is24,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), T = C(() => {
      const $ = [{ type: "hours" }, "separator", { type: "minutes" }];
      return t.enableSeconds ? $.concat(["separator", { type: "seconds" }]) : $;
    }), te = C(() => T.value.filter(($) => typeof $ != "string")), l = C(() => ($) => {
      if ($ === "hours") {
        const D = U(t.hours);
        return { text: D < 10 ? `0${D}` : `${D}`, value: D };
      }
      return { text: t[$] < 10 ? `0${t[$]}` : `${t[$]}`, value: t[$] };
    }), o = ($) => {
      const D = $ === "hours" ? t.is24 ? 24 : 12 : 60, u = +t[`${$}GridIncrement`], s = [];
      for (let k = 0; k < D; k += u)
        s.push({ value: k, text: k < 10 ? `0${k}` : `${k}` });
      return Gl(s);
    }, F = ($) => t[`no${$[0].toUpperCase() + $.slice(1)}Overlay`], J = ($) => {
      F($) || (f[$] = !f[$], f[$] || n("overlay-closed"));
    }, _ = ($, D = !0) => {
      const u = $ === "hours" ? Re : $ === "minutes" ? Ve : Ge, s = D ? Sl : Al;
      n(`update:${$}`, u(s({ [$]: +t[$] }, { [$]: +t[`${$}Increment`] })));
    }, U = ($) => t.is24 ? $ : ($ >= 12 ? m.value = "PM" : m.value = "AM", ql($)), X = () => {
      m.value === "PM" ? (m.value = "AM", n("update:hours", t.hours - 12)) : (m.value = "PM", n("update:hours", t.hours + 12));
    }, Z = ($) => {
      f[$] = !0;
    }, Q = ($, D, u) => {
      if ($ && (h == null ? void 0 : h.value)) {
        Array.isArray(M.value[D]) ? M.value[D][u] = $ : M.value[D] = [$];
        const s = M.value.reduce(
          (k, E) => E.map((ee, I) => [...k[I] || [], E[I]]),
          []
        );
        O(t.closeTimePickerBtn), v.value && (s[1] = s[1].concat(v.value)), Y(s, t.order);
      }
    }, j = ($, D) => $ === "hours" && !t.is24 ? n(`update:${$}`, m.value === "PM" ? D + 12 : D) : n(`update:${$}`, D);
    return a({ openChildCmp: Z }), ($, D) => e.disabled ? b("", !0) : (g(), S("div", Pr, [
      (g(!0), S(se, null, ye(i(T), (u, s) => (g(), S("div", {
        key: s,
        class: fe(i(L))
      }, [
        u === "separator" ? (g(), S(se, { key: 0 }, [
          Cr
        ], 64)) : (g(), S(se, { key: 1 }, [
          H("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": i(y).incrementValue(u.type),
            tabindex: "0",
            onKeydown: de((k) => _(u.type), ["enter"]),
            onClick: (k) => _(u.type),
            ref_for: !0,
            ref: (k) => Q(k, s, 0)
          }, [
            $.$slots["arrow-up"] ? W($.$slots, "arrow-up", { key: 0 }) : b("", !0),
            $.$slots["arrow-up"] ? b("", !0) : (g(), le(i(Ln), { key: 1 }))
          ], 40, Tr),
          H("div", {
            role: "button",
            "aria-label": i(y).openTpOverlay(u.type),
            class: fe(F(u.type) ? "" : "dp__time_display"),
            tabindex: "0",
            onKeydown: de((k) => J(u.type), ["enter"]),
            onClick: (k) => J(u.type),
            ref_for: !0,
            ref: (k) => Q(k, s, 1)
          }, [
            $.$slots[u.type] ? W($.$slots, u.type, {
              key: 0,
              text: i(l)(u.type).text,
              value: i(l)(u.type).value
            }) : b("", !0),
            $.$slots[u.type] ? b("", !0) : (g(), S(se, { key: 1 }, [
              Fe(ge(i(l)(u.type).text), 1)
            ], 64))
          ], 42, _r),
          H("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": i(y).decrementValue(u.type),
            tabindex: "0",
            onKeydown: de((k) => _(u.type, !1), ["enter"]),
            onClick: (k) => _(u.type, !1),
            ref_for: !0,
            ref: (k) => Q(k, s, 2)
          }, [
            $.$slots["arrow-down"] ? W($.$slots, "arrow-down", { key: 0 }) : b("", !0),
            $.$slots["arrow-down"] ? b("", !0) : (g(), le(i(Gn), { key: 1 }))
          ], 40, Rr)
        ], 64))
      ], 2))), 128)),
      $.is24 ? b("", !0) : (g(), S("div", Vr, [
        $.$slots["am-pm-button"] ? W($.$slots, "am-pm-button", {
          key: 0,
          toggle: X,
          value: m.value
        }) : b("", !0),
        $.$slots["am-pm-button"] ? b("", !0) : (g(), S("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: v,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": i(y).amPmButton,
          tabindex: "0",
          onClick: X,
          onKeydown: de(Ue(X, ["prevent"]), ["enter"])
        }, ge(m.value), 41, Br))
      ])),
      (g(!0), S(se, null, ye(i(te), (u, s) => (g(), le(yt, {
        key: s,
        name: i(R)(f[u.type]),
        css: i(B)
      }, {
        default: ae(() => [
          f[u.type] ? (g(), le($t, {
            key: 0,
            items: o(u.type),
            "disabled-values": e.filters.times[u.type],
            "onUpdate:modelValue": (k) => j(u.type, k),
            onSelected: (k) => J(u.type),
            onToggle: (k) => J(u.type),
            onResetFlow: D[0] || (D[0] = (k) => $.$emit("reset-flow"))
          }, Pe({
            "button-icon": ae(() => [
              $.$slots["clock-icon"] ? W($.$slots, "clock-icon", { key: 0 }) : b("", !0),
              $.$slots["clock-icon"] ? b("", !0) : (g(), le(i(Un), { key: 1 }))
            ]),
            _: 2
          }, [
            $.$slots[`${u.type}-overlay`] ? {
              name: "item",
              fn: ae(({ item: k }) => [
                W($.$slots, `${u.type}-overlay`, {
                  text: k.text,
                  value: k.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : b("", !0)
        ]),
        _: 2
      }, 1032, ["name", "css"]))), 128))
    ]));
  }
}), wt = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["calendar", "month-year"] },
  { name: "hours-overlay", use: ["calendar", "time"] },
  { name: "minutes-overlay", use: ["calendar", "time"] },
  { name: "seconds-overlay", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] }
], Nr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Ir = {
  all: () => wt,
  monthYear: () => wt.filter((e) => e.use.includes("month-year")),
  input: () => Nr,
  timePicker: () => wt.filter((e) => e.use.includes("time")),
  action: () => wt.filter((e) => e.use.includes("action")),
  calendar: () => wt.filter((e) => e.use.includes("calendar"))
}, at = (e, a) => {
  const n = [];
  return Ir[a]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
}, Yr = ["aria-label"], Er = { class: "dp__overlay_container dp__container_flex" }, Fr = {
  key: 1,
  class: "dp__overlay_row"
}, Wr = ["aria-label"], Kr = /* @__PURE__ */ Be({
  __name: "TimePicker",
  props: {
    ...xn,
    range: { type: Boolean, default: !1 },
    filters: { type: Object, default: () => ({}) },
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    customProps: { type: Object, default: null },
    modelAuto: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null }
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, f = dn(), m = V(null), v = V(null), y = ve(vn, !1), h = V([]), M = V(null), R = ve(ze), B = ve(Xe), { transitionName: Y, showTransition: O } = Ut(), { buildMatrix: L, setTimePicker: T } = qe();
    Oe(() => {
      n("mount"), !t.timePicker && (B == null ? void 0 : B.value) ? L([ke(m.value)], "time") : T(!0, t.timePicker);
    });
    const te = C(() => t.range && t.modelAuto ? oa(t.internalModelValue) : !0), l = V(!1), o = (D) => ({
      hours: Array.isArray(t.hours) ? t.hours[D] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[D] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[D] : t.seconds
    }), F = C(() => {
      const D = [];
      if (t.range)
        for (let u = 0; u < 2; u++)
          D.push(o(u));
      else
        D.push(o(0));
      return D;
    }), J = (D, u = !1, s = "") => {
      u || n("reset-flow"), l.value = D, B != null && B.value && (T(D), D || n("overlay-closed")), St(() => {
        s !== "" && h.value[0] && h.value[0].openChildCmp(s);
      });
    }, _ = C(() => ({
      dp__button: !0,
      dp__button_bottom: y
    })), U = at(f, "timePicker"), X = (D, u, s) => t.range ? u === 0 ? [D, F.value[1][s]] : [F.value[0][s], D] : D, Z = (D) => {
      n("update:hours", D);
    }, Q = (D) => {
      n("update:minutes", D);
    }, j = (D) => {
      n("update:seconds", D);
    }, $ = () => {
      M.value && (B == null ? void 0 : B.value) && M.value.focus({ preventScroll: !0 });
    };
    return a({ toggleTimePicker: J }), (D, u) => (g(), S("div", null, [
      D.timePicker ? b("", !0) : (g(), S("div", {
        key: 0,
        class: fe(i(_)),
        role: "button",
        "aria-label": i(R).openTimePicker,
        tabindex: "0",
        ref_key: "openTimePickerBtn",
        ref: m,
        onKeydown: u[0] || (u[0] = de((s) => J(!0), ["enter"])),
        onClick: u[1] || (u[1] = (s) => J(!0))
      }, [
        D.$slots["clock-icon"] ? W(D.$slots, "clock-icon", { key: 0 }) : b("", !0),
        D.$slots["clock-icon"] ? b("", !0) : (g(), le(i(Un), { key: 1 }))
      ], 42, Yr)),
      je(yt, {
        name: i(Y)(l.value),
        css: i(O)
      }, {
        default: ae(() => [
          l.value || D.timePicker ? (g(), S("div", {
            key: 0,
            class: "dp__overlay",
            ref_key: "overlayRef",
            ref: M,
            tabindex: "0"
          }, [
            H("div", Er, [
              D.$slots["time-picker-overlay"] ? W(D.$slots, "time-picker-overlay", {
                key: 0,
                range: e.range,
                hours: e.hours,
                minutes: e.minutes,
                seconds: e.seconds,
                setHours: Z,
                setMinutes: Q,
                setSeconds: j
              }) : b("", !0),
              D.$slots["time-picker-overlay"] ? b("", !0) : (g(), S("div", Fr, [
                (g(!0), S(se, null, ye(i(F), (s, k) => $a((g(), le(Or, Ae({
                  key: k,
                  disabled: k === 0 ? D.fixedStart : D.fixedEnd,
                  hours: s.hours,
                  minutes: s.minutes,
                  seconds: s.seconds,
                  filters: e.filters,
                  ref_for: !0,
                  ref_key: "timeInputRefs",
                  ref: h
                }, {
                  is24: D.is24,
                  hoursGridIncrement: D.hoursGridIncrement,
                  minutesGridIncrement: D.minutesGridIncrement,
                  secondsGridIncrement: D.secondsGridIncrement,
                  hoursIncrement: D.hoursIncrement,
                  minutesIncrement: D.minutesIncrement,
                  secondsIncrement: D.secondsIncrement,
                  filters: e.filters,
                  noHoursOverlay: D.noHoursOverlay,
                  noMinutesOverlay: D.noMinutesOverlay,
                  noSecondsOverlay: D.noSecondsOverlay,
                  enableSeconds: D.enableSeconds,
                  closeTimePickerBtn: v.value,
                  order: k
                }, {
                  "onUpdate:hours": (E) => Z(X(E, k, "hours")),
                  "onUpdate:minutes": (E) => Q(X(E, k, "minutes")),
                  "onUpdate:seconds": (E) => j(X(E, k, "seconds")),
                  onMounted: $,
                  onOverlayClosed: $
                }), Pe({ _: 2 }, [
                  ye(i(U), (E, ee) => ({
                    name: E,
                    fn: ae((I) => [
                      W(D.$slots, E, Le(nt(I)))
                    ])
                  }))
                ]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                  [Ma, k === 0 ? !0 : i(te)]
                ])), 128))
              ])),
              D.timePicker ? b("", !0) : (g(), S("div", {
                key: 2,
                ref_key: "closeTimePickerBtn",
                ref: v,
                class: fe(i(_)),
                role: "button",
                "aria-label": i(R).closeTimePicker,
                tabindex: "0",
                onKeydown: u[2] || (u[2] = de((s) => J(!1), ["enter"])),
                onClick: u[3] || (u[3] = (s) => J(!1))
              }, [
                D.$slots["calendar-icon"] ? W(D.$slots, "calendar-icon", { key: 0 }) : b("", !0),
                D.$slots["calendar-icon"] ? b("", !0) : (g(), le(i(Kt), { key: 1 }))
              ], 42, Wr))
            ])
          ], 512)) : b("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ]));
  }
}), Hr = (e, a, n, t) => {
  const f = V(new Date()), m = V(), v = V([{ month: me(new Date()), year: ue(new Date()) }]), y = V(
    e.range ? [Re(new Date()), Re(new Date())] : Re(new Date())
  ), h = V(
    e.range ? [Ve(new Date()), Ve(new Date())] : Ve(new Date())
  ), M = V(e.range ? [0, 0] : 0);
  Mt(
    v,
    () => {
      setTimeout(() => {
        e.openOnTop && a("dpOpen");
      }, 0);
    },
    { deep: !0 }
  ), Oe(() => {
    Q(!0), l.value || (e.startDate && (v.value[0].month = me(new Date(e.startDate)), v.value[0].year = ue(new Date(e.startDate)), e.multiCalendars && N(0)), e.startTime && te());
  });
  const R = C(
    () => (r) => v.value[r] ? v.value[r].month : 0
  ), B = C(
    () => (r) => v.value[r] ? v.value[r].year : 0
  ), Y = (r, w, A) => {
    v.value[r].month = w, v.value[r].year = A;
  }, O = (r, w) => v.value[r].month = w, L = (r, w) => v.value[r].year = w, T = (r = !0) => e.enableSeconds ? Array.isArray(M.value) ? r ? M.value[0] : M.value[1] : M.value : 0, te = () => {
    e.startTime && (Kl(e.startTime) ? (y.value = [+e.startTime[0].hours, +e.startTime[1].hours], h.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (M.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (y.value = +e.startTime.hours, h.value = +e.startTime.minutes, e.enableSeconds && (M.value = +e.startTime.seconds)));
  }, l = C({
    get: () => e.internalModelValue,
    set: (r) => {
      !e.readonly && !e.disabled && a("update:internalModelValue", r);
    }
  });
  Mt(l, () => Q());
  const o = (r) => {
    const { validate: w } = qn(
      e.minDate,
      e.maxDate,
      e.disabledDates,
      e.allowedDates,
      e.filters,
      e.disabledWeekDays,
      e.yearRange
    );
    return !w(r);
  }, F = (r) => !l.value || e.hideOffsetDates && !r.current ? !1 : e.range ? e.modelAuto && Array.isArray(l.value) ? ie(r.value, l.value[0] ? l.value[0] : f.value) : !1 : e.multiDates && Array.isArray(l.value) ? l.value.some((w) => ie(w, r.value)) : ie(r.value, l.value ? l.value : f.value), J = (r) => zn(l.value, m.value, r.value), _ = (r, w = !1) => {
    if ((!e.multiCalendars || !e.multiStatic || w) && (O(0, me(r)), L(0, ue(r))), e.multiCalendars)
      for (let A = 1; A <= e.multiCalendars; A++) {
        const q = Ce(new Date(), { month: R.value(A - 1), year: B.value(A - 1) }), Me = Kn(q, { months: 1 });
        v.value[A] = { month: me(Me), year: ue(Me) };
      }
  }, U = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const r = new Date(l.value[1] ? l.value[1] : vt(l.value[0], 1)), [w, A] = [me(l.value[0]), ue(l.value[0])], [q, Me] = [me(l.value[1]), ue(l.value[1])];
      (w !== q || w === q && A !== Me) && e.multiCalendarsSolo && (O(1, me(r)), L(1, ue(r)));
    }
  }, X = (r) => {
    _(r), y.value = Re(r), h.value = Ve(r), M.value = Ge(r);
  }, Z = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null, Q = (r = !1) => {
    if (l.value)
      if (bt(l.value)) {
        if (l.value.length === 2 && !e.multiDates)
          _(l.value[0], r), y.value = [
            Re(l.value[0]),
            l.value[1] ? Re(l.value[1]) : Re(new Date())
          ], h.value = [
            Ve(l.value[0]),
            l.value[1] ? Ve(l.value[1]) : Ve(new Date())
          ], M.value = [
            Ge(l.value[0]),
            l.value[1] ? Ge(l.value[1]) : Ge(new Date())
          ];
        else if (bt(l.value) && e.multiDates) {
          const w = l.value[l.value.length - 1];
          w && X(w);
        }
        e.multiCalendars && e.multiCalendarsSolo && U();
      } else
        X(l.value);
    else
      e.timePicker ? (te(), e.range ? _e(y.value) && _e(h.value) && (l.value = [
        Se(new Date(), y.value[0], h.value[0], T()),
        Se(new Date(), y.value[1], h.value[1], T(!1))
      ]) : l.value = Se(
        new Date(),
        y.value,
        h.value,
        T()
      )) : e.monthPicker && !e.range ? l.value = rt(new Date(), R.value(0), B.value(0)) : e.multiCalendars ? _(new Date()) : e.yearPicker && !e.range && (l.value = new Date());
  }, j = (r) => {
    const w = me(new Date(r)), A = ue(new Date(r));
    if (O(0, w), L(0, A), e.multiCalendars > 0)
      for (let q = 1; q < e.multiCalendars; q++) {
        const Me = Ml(
          Ce(new Date(r), { year: R.value(q - 1), month: B.value(q - 1) })
        );
        O(q, Me.month), L(q, Me.year);
      }
  }, $ = (r) => {
    if (l.value && Array.isArray(l.value))
      if (l.value.some((w) => ie(r, w))) {
        const w = l.value.filter((A) => !ie(A, r));
        l.value = w.length ? w : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > l.value.length || !e.multiDatesLimit) && l.value.push(r);
    else
      l.value = [r];
  }, D = (r) => {
    if (Array.isArray(l.value) && l.value[0]) {
      const w = Ia(r, l.value[0]), A = $e(l.value[0], r) ? r : l.value[0], q = $e(r, l.value[0]) ? r : l.value[0], xe = Mn({ start: A, end: q }).filter((ut) => o(ut)).length, Te = Math.abs(w < 0 ? w + 1 : w - 1) - xe;
      if (e.minRange && e.maxRange)
        return Te >= +e.minRange && Te <= +e.maxRange;
      if (e.minRange)
        return Te >= +e.minRange;
      if (e.maxRange)
        return Te <= +e.maxRange;
    }
    return !0;
  }, u = (r) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && ($e(r, l.value[0]) || ie(r, l.value[0])) ? [l.value[0], r] : e.fixedEnd && (we(r, l.value[1]) || ie(r, l.value[1])) ? [r, l.value[1]] : l.value : [], s = () => {
    e.autoApply && a("autoApply");
  }, k = (r) => !Mn({ start: r[0], end: r[1] }).some((A) => o(A)), E = (r, w = !1) => {
    if (!o(r.value) && !(!r.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return l.value = Tt(new Date(r.value), +e.weekStart), s();
      if (!e.range && !_e(y.value) && !_e(h.value)) {
        const A = Se(new Date(r.value), y.value, h.value, T());
        e.multiDates ? $(A) : l.value = A, n(), s();
      } else if (_e(y.value) && _e(h.value) && !e.multiDates) {
        let A = l.value ? l.value.slice() : [];
        if (A.length === 2 && !(e.fixedStart || e.fixedEnd) && (A = []), e.autoRange) {
          const q = [new Date(r.value), Dt(new Date(r.value), +e.autoRange)];
          k(q) && (w && j(r.value), A = q);
        } else
          e.fixedStart || e.fixedEnd ? A = u(new Date(r.value)) : A[0] ? D(new Date(r.value)) && (we(new Date(r.value), new Date(A[0])) ? A.unshift(new Date(r.value)) : A[1] = new Date(r.value)) : A[0] = new Date(r.value);
        A.length && (A[0] && !A[1] ? A[0] = Se(A[0], y.value[0], h.value[0], T()) : (A[0] = Se(A[0], y.value[0], h.value[0], T()), A[1] = Se(A[1], y.value[1], h.value[1], T(!1)), n()), l.value = A, A[0] && A[1] && e.autoApply && a("autoApply"));
      }
    }
  }, ee = (r) => {
    const w = r.find((A) => A.current);
    return w ? Na(w.value) : "";
  }, I = (r) => {
    !r.current && e.hideOffsetDates || (m.value = r.value);
  }, re = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return !1;
        const w = Dt(m.value, +e.autoRange), A = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ie(A[1], new Date(r.value)) : ie(w, new Date(r.value));
      }
      return !1;
    }
    return !1;
  }, p = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        const w = Dt(m.value, +e.autoRange);
        if (e.hideOffsetDates && !r.current)
          return !1;
        const A = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? $e(r.value, A[0]) && we(r.value, A[1]) : $e(r.value, m.value) && we(r.value, w);
      }
      return !1;
    }
    return !1;
  }, P = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return !1;
        const w = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ie(w[0], r.value) : ie(m.value, r.value);
      }
      return !1;
    }
    return !1;
  }, N = (r) => {
    for (let w = r - 1; w >= 0; w--) {
      const A = Et(Ce(new Date(), { month: R.value(w + 1), year: B.value(w + 1) }), 1);
      Y(w, me(A), ue(A));
    }
    for (let w = r + 1; w <= e.multiCalendars - 1; w++) {
      const A = vt(Ce(new Date(), { month: R.value(w - 1), year: B.value(w - 1) }), 1);
      Y(w, me(A), ue(A));
    }
  }, pe = (r) => rt(new Date(), R.value(r), B.value(r)), Ee = (r, w) => {
    const A = e.monthPicker ? R.value(r) !== w.month : B.value(r) !== w.year;
    if (O(r, w.month), L(r, w.year), e.multiCalendars && !e.multiCalendarsSolo && N(r), e.monthPicker || e.yearPicker)
      if (e.range) {
        if (A) {
          let q = l.value ? l.value.slice() : [];
          q.length === 2 && q[1] !== null && (q = []), q.length ? we(pe(r), q[0]) ? q.unshift(pe(r)) : q[1] = pe(r) : q = [pe(r)], l.value = q;
        }
      } else
        l.value = pe(r);
    n(), a("updateMonthYear", { instance: r, month: w.month, year: w.year }), At(e.multiCalendarsSolo ? r : void 0);
  }, Je = (r) => Se(r, y.value, h.value, T()), Ne = (r) => {
    bt(r) && bt(l.value) && _e(y.value) && _e(h.value) ? (r[0] && l.value[0] && (l.value[0] = Se(r[0], y.value[0], h.value[0], T())), r[1] && l.value[1] && (l.value[1] = Se(
      r[1],
      y.value[1],
      h.value[1],
      T(!1)
    ))) : e.multiDates && Array.isArray(l.value) ? l.value[l.value.length - 1] = Je(r) : !e.range && !It(r) && (l.value = Je(r)), a("timeUpdate");
  }, We = (r, w = !0, A = !1) => {
    const q = w ? r : y.value, Me = !w && !A ? r : h.value, xe = A ? r : M.value;
    if (e.range && It(l.value) && _e(q) && _e(Me) && _e(xe) && !e.disableTimeRangeValidation) {
      const Te = (He) => Se(l.value[He], q[He], Me[He], xe[He]), ut = (He) => cn(l.value[He], 0);
      if (ie(l.value[0], l.value[1]) && (fn(Te(0), ut(1)) || mn(Te(1), ut(0))))
        return;
    }
    if (y.value = q, h.value = Me, M.value = xe, l.value)
      if (e.multiDates) {
        const Te = Z();
        Te && Ne(Te);
      } else
        Ne(l.value);
    else
      e.timePicker && Ne(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, Ke = () => {
    m.value = null;
  }, Ze = (r) => Rn(l.value, e.range) && l.value[0] && m.value ? r ? $e(m.value, l.value[0]) : we(m.value, l.value[0]) : !0, be = (r, w = !0) => (e.range || e.weekPicker) && It(l.value) ? e.hideOffsetDates && !r.current ? !1 : ie(new Date(r.value), l.value[w ? 0 : 1]) : e.range ? ie(
    new Date(r.value),
    l.value && Array.isArray(l.value) ? w ? l.value[0] || null : l.value[1] : null
  ) && (w ? !we(
    m.value || null,
    Array.isArray(l.value) ? l.value[0] : null
  ) : !0) || ie(r.value, Array.isArray(l.value) ? l.value[0] : null) && Ze(w) : !1, ot = (r, w) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? !1 : !r && !F(w) && !(!w.current && e.hideOffsetDates) && (e.range ? !be(w) && !be(w, !1) : !0), pt = (r, w, A) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? r ? !1 : A ? $e(e.internalModelValue[0], w.value) : we(e.internalModelValue[0], w.value) : !1, ht = (r = !1) => {
    e.autoApply && (e.monthPicker || e.yearPicker) && St().then(() => {
      e.range ? a("autoApply", r || !l.value || l.value.length === 1) : a("autoApply", r);
    });
  }, c = (r, w) => {
    const A = Ce(new Date(), { month: R.value(w), year: B.value(w) }), q = r < 0 ? vt(A, 1) : Et(A, 1);
    ia(
      e.minDate,
      e.maxDate,
      me(q),
      ue(q),
      r < 0,
      e.preventMinMaxNavigation
    ) && (Y(w, me(q), ue(q)), e.multiCalendars && !e.multiCalendarsSolo && N(w), At());
  }, ne = (r, w) => {
    e.monthChangeOnScroll && c(e.monthChangeOnScroll !== "inverse" ? -r.deltaY : r.deltaY, w);
  }, ce = (r, w, A = !1) => {
    e.monthChangeOnArrows && e.vertical === A && it(r, w);
  }, it = (r, w) => {
    c(r === "right" ? -1 : 1, w);
  }, Qe = (r) => e.markers.find((w) => ie(Ie(r.value), Ie(w.date))), Lt = () => {
    e.range ? Rn(l.value, e.range) && (l.value && l.value[0] ? l.value = we(new Date(), l.value[0]) ? [new Date(), l.value[0]] : [l.value[0], new Date()] : l.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, Gt = (r) => {
    r.length && r.length <= 2 && e.range && (l.value = r.map((w) => new Date(w)), e.autoApply && a("selectDate"));
  }, At = (r) => {
    r || r === 0 ? t.value[r].triggerTransition(R.value(r), B.value(r)) : t.value.forEach((w, A) => w.triggerTransition(R.value(A), B.value(A)));
  };
  return {
    today: f,
    hours: y,
    minutes: h,
    seconds: M,
    month: R,
    year: B,
    monthYearSelect: ht,
    isDisabled: o,
    updateTime: We,
    setHoverDate: I,
    getWeekNum: ee,
    selectDate: E,
    rangeActive: J,
    isActiveDate: F,
    updateMonthYear: Ee,
    isHoverRangeEnd: re,
    isAutoRangeInBetween: p,
    isAutoRangeStart: P,
    clearHoverDate: Ke,
    rangeActiveStartEnd: be,
    handleScroll: ne,
    getMarker: Qe,
    handleArrow: ce,
    handleSwipe: it,
    selectCurrentDate: Lt,
    isHoverDate: ot,
    isHoverDateStartEnd: pt,
    presetDateRange: Gt
  };
}, Rt = Wt({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), ua = () => ({
  setMenuFocused: (t) => {
    Rt.menuFocused = t;
  },
  getStore: () => Rt,
  setShiftKey: (t) => {
    Rt.shiftKeyInMenu !== t && (Rt.shiftKeyInMenu = t);
  }
}), Ur = ["id", "aria-label", "onKeydown"], Lr = {
  key: 0,
  class: "dp__preset_ranges"
}, Gr = ["onClick"], jr = {
  key: 1,
  class: "dp__now_wrap"
}, zr = /* @__PURE__ */ Be({
  __name: "DatepickerMenu",
  props: {
    ...la,
    ...pn,
    ...yn,
    internalModelValue: { type: [Date, Array], default: null },
    multiCalendars: { type: Number, default: 0 },
    openOnTop: { type: Boolean, default: !1 }
  },
  emits: [
    "update:internalModelValue",
    "closePicker",
    "selectDate",
    "dpOpen",
    "autoApply",
    "timeUpdate",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { emit: a }) {
    const n = e, t = dn(), f = V(null), m = Wt({
      timePicker: !!(!n.enableTimePicker || n.timePicker || n.monthPicker),
      monthYearInput: !!n.timePicker,
      calendar: !1
    }), v = V([]), y = V([]), h = V(null), M = V(null), R = V(0), B = V(!1), Y = V(0), O = ve(Ht), L = ve(ze), T = ve(Xe), { setMenuFocused: te, setShiftKey: l, getStore: o } = ua();
    Oe(() => {
      var G;
      B.value = !0, (G = n.presetRanges) != null && G.length || q();
      const d = ke(M);
      if (d && !n.textInput && !n.inline && (te(!0), X()), d) {
        const K = (z) => {
          !n.monthYearComponent && !n.timePickerComponent && z.preventDefault(), z.stopImmediatePropagation(), z.stopPropagation();
        };
        d.addEventListener("pointerdown", K), d.addEventListener("mousedown", K);
      }
      document.addEventListener("resize", q);
    }), un(() => {
      document.removeEventListener("resize", q);
    });
    const { arrowRight: F, arrowLeft: J, arrowDown: _, arrowUp: U } = qe(), X = () => {
      const d = ke(M);
      d && d.focus({ preventScroll: !0 });
    }, Z = () => {
      var d;
      ((d = n.flow) == null ? void 0 : d.length) && Y.value !== -1 && (Y.value += 1, a("flow-step", Y.value), kn());
    }, Q = () => {
      Y.value = -1;
    }, {
      updateTime: j,
      updateMonthYear: $,
      today: D,
      month: u,
      year: s,
      hours: k,
      minutes: E,
      seconds: ee,
      isDisabled: I,
      isActiveDate: re,
      selectDate: p,
      getWeekNum: P,
      setHoverDate: N,
      isHoverRangeEnd: pe,
      isAutoRangeInBetween: Ee,
      isAutoRangeStart: Je,
      rangeActive: Ne,
      clearHoverDate: We,
      rangeActiveStartEnd: Ke,
      monthYearSelect: Ze,
      handleScroll: be,
      handleArrow: ot,
      handleSwipe: pt,
      getMarker: ht,
      selectCurrentDate: c,
      isHoverDateStartEnd: ne,
      isHoverDate: ce,
      presetDateRange: it
    } = Hr(n, a, Z, y), Qe = at(t, "calendar"), Lt = at(t, "action"), Gt = at(t, "timePicker"), At = at(t, "monthYear"), r = C(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), w = C(() => zl(n.yearRange)), A = C(() => Xl(n.locale, n.monthNameFormat)), q = () => {
      const d = ke(f);
      d && (R.value = d.getBoundingClientRect().width);
    }, Me = C(
      () => (d) => Ll(
        u.value(d),
        s.value(d),
        +n.weekStart,
        n.hideOffsetDates
      )
    ), xe = C(
      () => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]
    ), Te = C(
      () => (d) => d === 1
    ), ut = C(() => n.monthPicker || n.timePicker || n.yearPicker), He = C(
      () => ({
        dp__flex_display: n.multiCalendars > 0
      })
    ), ca = C(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    })), fa = C(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly
    })), ma = C(
      () => (d) => ha(Me, d)
    ), va = C(() => ({
      locale: n.locale,
      weekNumName: n.weekNumName,
      weekStart: n.weekStart,
      weekNumbers: n.weekNumbers,
      customProps: n.customProps,
      calendarClassName: n.calendarClassName,
      specificMode: ut.value,
      getWeekNum: P,
      multiCalendars: n.multiCalendars,
      modeHeight: n.modeHeight,
      internalModelValue: n.internalModelValue,
      noSwipe: n.noSwipe,
      vertical: n.vertical,
      dayNames: n.dayNames,
      monthChangeOnScroll: n.monthChangeOnScroll
    })), ya = C(
      () => ({
        dp__menu: !0,
        dp__menu_index: !n.inline,
        dp__relative: n.inline,
        [n.menuClassName]: !!n.menuClassName
      })
    ), pa = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, gt = () => n.modelAuto ? oa(n.internalModelValue) : !0, ha = (d, G) => d.value(G).map((K) => ({
      ...K,
      days: K.days.map((z) => {
        const x = I(z.value), kt = ce(x, z), et = n.range ? n.modelAuto ? pa() && re(z) : !1 : re(z), wn = n.highlight ? Xn(z.value, n.highlight) : !1, bn = n.highlightWeekDays && n.highlightWeekDays.includes(z.value.getDay()), Dn = (n.range || n.weekPicker) && (n.multiCalendars > 0 ? z.current : !0) && !x && gt() && !(!z.current && n.hideOffsetDates) && !re(z) ? Ne(z) : !1;
        return z.marker = ht(z), z.classData = {
          dp__cell_offset: !z.current,
          dp__pointer: !x && !(!z.current && n.hideOffsetDates),
          dp__active_date: et,
          dp__date_hover: kt,
          dp__date_hover_start: ne(kt, z, !0),
          dp__date_hover_end: ne(kt, z, !1),
          dp__range_between: Dn && !n.weekPicker,
          dp__range_between_week: Dn && n.weekPicker,
          dp__today: !n.noToday && ie(z.value, D.value) && z.current,
          dp__cell_disabled: x,
          dp__cell_auto_range: Ee(z),
          dp__cell_auto_range_start: Je(z),
          dp__cell_auto_range_end: pe(z),
          dp__range_start: n.multiCalendars > 0 ? z.current && Ke(z) && gt() : Ke(z) && gt(),
          dp__range_end: n.multiCalendars > 0 ? z.current && Ke(z, !1) && gt() : Ke(z, !1) && gt(),
          [n.calendarCellClassName]: !!n.calendarCellClassName,
          dp__cell_highlight: (wn || bn) && !et,
          dp__cell_highlight_active: (wn || bn) && et
        }, z;
      })
    })), ga = (d) => {
      d.stopPropagation(), d.preventDefault(), d.stopImmediatePropagation();
    }, ka = () => {
      n.escClose && a("closePicker");
    }, wa = (d) => {
      d.stopImmediatePropagation(), d.preventDefault(), n.spaceConfirm && a("selectDate");
    }, jt = (d) => {
      var G;
      (G = n.flow) != null && G.length && (m[d] = !0, Object.keys(m).filter((K) => !m[K]).length || kn());
    }, kn = () => {
      n.flow[Y.value] === "month" && v.value[0] && v.value[0].toggleMonthPicker(!0), n.flow[Y.value] === "year" && v.value && v.value[0].toggleYearPicker(!0), n.flow[Y.value] === "calendar" && h.value && h.value.toggleTimePicker(!1, !0), n.flow[Y.value] === "time" && h.value && h.value.toggleTimePicker(!0, !0);
      const d = n.flow[Y.value];
      (d === "hours" || d === "minutes" || d === "seconds") && h.value && h.value.toggleTimePicker(!0, !0, d);
    }, Pt = (d) => {
      if (T != null && T.value) {
        if (d === "up")
          return U();
        if (d === "down")
          return _();
        if (d === "left")
          return J();
        if (d === "right")
          return F();
      } else
        d === "left" || d === "up" ? ot("left", 0, d === "up") : ot("right", 0, d === "down");
    }, ba = (d) => {
      l(d.shiftKey), !n.disableMonthYearSelect && d.code === "Tab" && d.target.classList.contains("dp__menu") && o().shiftKeyInMenu && (d.preventDefault(), d.stopImmediatePropagation(), a("closePicker"));
    };
    return (d, G) => (g(), le(yt, {
      appear: "",
      name: i(O).menuAppear,
      mode: "out-in",
      css: !!i(O)
    }, {
      default: ae(() => [
        H("div", {
          id: d.uid ? `dp-menu-${d.uid}` : void 0,
          tabindex: "0",
          ref_key: "dpMenuRef",
          ref: M,
          role: "dialog",
          "aria-label": i(L).menu,
          class: fe(i(ya)),
          onMouseleave: G[12] || (G[12] = (...K) => i(We) && i(We)(...K)),
          onClick: ga,
          onKeydown: [
            de(ka, ["esc"]),
            de(wa, ["space"]),
            G[13] || (G[13] = de(Ue((K) => Pt("left"), ["prevent"]), ["left"])),
            G[14] || (G[14] = de(Ue((K) => Pt("up"), ["prevent"]), ["up"])),
            G[15] || (G[15] = de(Ue((K) => Pt("down"), ["prevent"]), ["down"])),
            G[16] || (G[16] = de(Ue((K) => Pt("right"), ["prevent"]), ["right"])),
            ba
          ]
        }, [
          (d.disabled || d.readonly) && d.inline ? (g(), S("div", {
            key: 0,
            class: fe(i(fa))
          }, null, 2)) : b("", !0),
          !d.inline && !d.teleportCenter ? (g(), S("div", {
            key: 1,
            class: fe(i(r))
          }, null, 2)) : b("", !0),
          H("div", {
            class: fe(d.presetRanges.length ? "dp__menu_content_wrapper" : null)
          }, [
            d.presetRanges.length ? (g(), S("div", Lr, [
              (g(!0), S(se, null, ye(d.presetRanges, (K, z) => (g(), S("div", {
                key: z,
                style: ft(K.style || {}),
                class: "dp__preset_range",
                onClick: (x) => i(it)(K.range)
              }, ge(K.label), 13, Gr))), 128))
            ])) : b("", !0),
            H("div", {
              class: "dp__instance_calendar",
              ref_key: "calendarWrapperRef",
              ref: f,
              role: "document"
            }, [
              H("div", {
                class: fe(i(He))
              }, [
                (g(!0), S(se, null, ye(i(xe), (K, z) => (g(), S("div", {
                  key: K,
                  class: fe(i(ca))
                }, [
                  !d.disableMonthYearSelect && !d.timePicker ? (g(), le(Vt(d.monthYearComponent ? d.monthYearComponent : Ar), Ae({
                    key: 0,
                    ref_for: !0,
                    ref: (x) => {
                      x && (v.value[z] = x);
                    }
                  }, {
                    months: i(A),
                    years: i(w),
                    filters: d.filters,
                    monthPicker: d.monthPicker,
                    month: i(u)(K),
                    year: i(s)(K),
                    customProps: d.customProps,
                    multiCalendars: e.multiCalendars,
                    multiCalendarsSolo: d.multiCalendarsSolo,
                    instance: K,
                    minDate: d.minDate,
                    maxDate: d.maxDate,
                    preventMinMaxNavigation: d.preventMinMaxNavigation,
                    internalModelValue: e.internalModelValue,
                    range: d.range,
                    reverseYears: d.reverseYears,
                    vertical: d.vertical,
                    yearPicker: d.yearPicker
                  }, {
                    onMount: G[0] || (G[0] = (x) => jt("monthYearInput")),
                    onResetFlow: Q,
                    onUpdateMonthYear: (x) => i($)(K, x),
                    onMonthYearSelect: i(Ze),
                    onOverlayClosed: X
                  }), Pe({ _: 2 }, [
                    ye(i(At), (x, kt) => ({
                      name: x,
                      fn: ae((et) => [
                        W(d.$slots, x, Le(nt(et)))
                      ])
                    }))
                  ]), 1040, ["onUpdateMonthYear", "onMonthYearSelect"])) : b("", !0),
                  je(vr, Ae({
                    ref_for: !0,
                    ref: (x) => {
                      x && (y.value[z] = x);
                    }
                  }, i(va), {
                    "flow-step": Y.value,
                    "onUpdate:flow-step": G[1] || (G[1] = (x) => Y.value = x),
                    instance: K,
                    "mapped-dates": i(ma)(K),
                    month: i(u)(K),
                    year: i(s)(K),
                    onSelectDate: (x) => i(p)(x, !i(Te)(K)),
                    onSetHoverDate: G[2] || (G[2] = (x) => i(N)(x)),
                    onHandleScroll: (x) => i(be)(x, K),
                    onHandleSwipe: (x) => i(pt)(x, K),
                    onMount: G[3] || (G[3] = (x) => jt("calendar")),
                    onResetFlow: Q
                  }), Pe({ _: 2 }, [
                    ye(i(Qe), (x, kt) => ({
                      name: x,
                      fn: ae((et) => [
                        W(d.$slots, x, Le(nt({ ...et })))
                      ])
                    }))
                  ]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])
                ], 2))), 128))
              ], 2),
              H("div", null, [
                d.enableTimePicker && !d.monthPicker && !d.weekPicker ? (g(), le(Vt(d.timePickerComponent ? d.timePickerComponent : Kr), Ae({
                  key: 0,
                  ref_key: "timePickerRef",
                  ref: h
                }, {
                  is24: d.is24,
                  hoursIncrement: d.hoursIncrement,
                  minutesIncrement: d.minutesIncrement,
                  hoursGridIncrement: d.hoursGridIncrement,
                  secondsIncrement: d.secondsIncrement,
                  minutesGridIncrement: d.minutesGridIncrement,
                  secondsGridIncrement: d.secondsGridIncrement,
                  noHoursOverlay: d.noHoursOverlay,
                  noMinutesOverlay: d.noMinutesOverlay,
                  noSecondsOverlay: d.noSecondsOverlay,
                  range: d.range,
                  filters: d.filters,
                  timePicker: d.timePicker,
                  hours: i(k),
                  minutes: i(E),
                  seconds: i(ee),
                  customProps: d.customProps,
                  enableSeconds: d.enableSeconds,
                  fixedStart: d.fixedStart,
                  fixedEnd: d.fixedEnd,
                  modelAuto: d.modelAuto,
                  internalModelValue: e.internalModelValue
                }, {
                  onMount: G[4] || (G[4] = (K) => jt("timePicker")),
                  "onUpdate:hours": G[5] || (G[5] = (K) => i(j)(K)),
                  "onUpdate:minutes": G[6] || (G[6] = (K) => i(j)(K, !1)),
                  "onUpdate:seconds": G[7] || (G[7] = (K) => i(j)(K, !1, !0)),
                  onResetFlow: Q,
                  onOverlayClosed: X
                }), Pe({ _: 2 }, [
                  ye(i(Gt), (K, z) => ({
                    name: K,
                    fn: ae((x) => [
                      W(d.$slots, K, Le(nt(x)))
                    ])
                  }))
                ]), 1040)) : b("", !0)
              ])
            ], 512),
            d.showNowButton ? (g(), S("div", jr, [
              d.$slots["now-button"] ? W(d.$slots, "now-button", {
                key: 0,
                selectCurrentDate: i(c)
              }) : b("", !0),
              d.$slots["now-button"] ? b("", !0) : (g(), S("button", {
                key: 1,
                type: "button",
                role: "button",
                class: "dp__now_button",
                onClick: G[8] || (G[8] = (...K) => i(c) && i(c)(...K))
              }, ge(d.nowButtonLabel), 1))
            ])) : b("", !0)
          ], 2),
          !d.autoApply || d.keepActionRow ? (g(), le(Vt(d.actionRowComponent ? d.actionRowComponent : lr), Ae({ key: 2 }, {
            calendarWidth: R.value,
            selectText: d.selectText,
            cancelText: d.cancelText,
            internalModelValue: e.internalModelValue,
            range: d.range,
            previewFormat: d.previewFormat,
            inline: d.inline,
            monthPicker: d.monthPicker,
            timePicker: d.timePicker,
            customProps: d.customProps,
            multiCalendars: e.multiCalendars,
            menuMount: B.value,
            maxTime: d.maxTime,
            minTime: d.minTime,
            enableTimePicker: d.enableTimePicker,
            minDate: d.minDate,
            maxDate: d.maxDate,
            multiDates: d.multiDates,
            modelAuto: d.modelAuto,
            partialRange: d.partialRange,
            ignoreTimeValidation: d.ignoreTimeValidation
          }, {
            onClosePicker: G[9] || (G[9] = (K) => d.$emit("closePicker")),
            onSelectDate: G[10] || (G[10] = (K) => d.$emit("selectDate")),
            onInvalidSelect: G[11] || (G[11] = (K) => d.$emit("invalid-select"))
          }), Pe({ _: 2 }, [
            ye(i(Lt), (K, z) => ({
              name: K,
              fn: ae((x) => [
                W(d.$slots, K, Le(nt({ ...x })))
              ])
            }))
          ]), 1040)) : b("", !0)
        ], 42, Ur)
      ]),
      _: 3
    }, 8, ["name", "css"]));
  }
}), Xr = (e, a, n, t, f, m, v, y, h, M, R, B, Y, O, L, T, te) => {
  const l = V(""), o = V();
  Mt(o, () => {
    te("internalModelChange", o.value);
  });
  const F = (u) => [Z(u[0]), u[1] ? Z(u[1]) : null], J = (u) => {
    let s = null;
    u ? a ? Yl(u) && "hours" in u[0] && "minutes" in u[0] ? s = [
      Se(null, +u[0].hours, +u[0].minutes, +u[0].seconds),
      Se(null, +u[1].hours, +u[1].minutes, +u[1].seconds)
    ] : Il(u) && (s = Se(null, +u.hours, +u.minutes, +u.seconds)) : n ? El(u) && "month" in u[0] && "year" in u[0] ? (s = [rt(null, +u[0].month, +u[0].year)], u[1] ? s[1] = rt(null, +u[1].month, +u[1].year) : !u[1] && f && (s[1] = null)) : Fl(u) && "month" in u && "year" in u && (s = rt(null, +u.month, +u.year)) : Y ? Array.isArray(u) ? s = [
      lt(new Date(), u[0]),
      !u[1] && f ? null : lt(new Date(), u[1])
    ] : s = lt(new Date(), u) : M && Array.isArray(u) ? s = u.map((k) => Z(k)) : B && Array.isArray(u) ? s = [new Date(u[0]), new Date(u[1])] : t ? T ? Array.isArray(u) ? s = F(u) : s = [Z(u), null] : Wl(u, f) && (s = F(u)) : Hl(u) && (s = Z(u)) : s = null, rn(s) ? (o.value = s, U()) : (o.value = null, l.value = "");
  }, _ = () => jn(
    e,
    m,
    y,
    n,
    a,
    B,
    Y,
    v
  ), U = () => {
    if (!o.value)
      l.value = "";
    else if (!e || typeof e == "string") {
      const u = _();
      Array.isArray(o.value) && M ? l.value = o.value.map((s) => mt(s, u, h == null ? void 0 : h.value)).join("; ") : l.value = mt(
        o.value,
        u,
        h == null ? void 0 : h.value,
        O == null ? void 0 : O.rangeSeparator,
        T
      );
    } else
      a ? l.value = e(sn(o.value)) : n ? l.value = e(Tn(o.value)) : l.value = e(o.value);
  }, X = () => o.value ? t ? f ? o.value.length >= 1 : o.value.length === 2 : !!o.value : !1, Z = (u) => {
    if (R) {
      const s = new Date(u);
      return R === "preserve" ? new Date(s.getTime() + s.getTimezoneOffset() * 6e4) : s;
    }
    return L ? L === "date" || L === "timestamp" ? new Date(u) : L === "format" && (typeof e == "string" || !e) ? ln(u, _(), new Date()) : ln(u, L, new Date()) : new Date(u);
  }, Q = (u) => L ? L === "timestamp" ? +u : L === "format" && (typeof e == "string" || !e) ? mt(u, _(), h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator) : mt(u, L, h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator) : u, j = (u) => {
    te("update:modelValue", u);
  }, $ = () => [
    Q(o.value[0]),
    o.value[1] ? Q(o.value[1]) : null
  ];
  return {
    parseExternalModelValue: J,
    formatInputValue: U,
    internalModelValue: o,
    inputValue: l,
    emitModelValue: () => {
      if (n)
        j(Tn(o.value));
      else if (a)
        j(sn(o.value));
      else if (B)
        j(o.value);
      else if (Y)
        j(
          Array.isArray(o.value) ? [
            ue(o.value[0]),
            o.value[1] ? ue(o.value[1]) : null
          ] : ue(o.value)
        );
      else {
        if (o.value && t && f && o.value.length === 1 && o.value.push(null), R) {
          let u;
          if (Array.isArray(o.value)) {
            const s = (k) => k && Zt(k, R === "preserve");
            T ? u = o.value[1] ? o.value.map(s) : Zt(o.value[0], R === "preserve") : u = o.value.map(s);
          } else
            u = Zt(o.value, R === "preserve");
          return j(u);
        }
        Array.isArray(o.value) && !M ? j(
          T ? o.value[1] ? $() : Q(o.value[0]) : $()
        ) : Array.isArray(o.value) && M ? j(o.value.map((u) => Q(u))) : j(Q(o.value));
      }
      U();
    },
    checkBeforeEmit: X
  };
};
var Yt = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Yt || {});
const qr = (e, a, n, t, f, m, v, y, h) => {
  const M = V({
    top: "0",
    left: "0",
    transform: "none"
  }), R = V(!1), B = 390, Y = (_) => {
    const U = _.getBoundingClientRect();
    return {
      left: U.left + window.scrollX,
      top: U.top + window.scrollY
    };
  }, O = (_) => {
    const U = _.getBoundingClientRect();
    let X = 0, Z = 0;
    for (; _ && !isNaN(_.offsetLeft) && !isNaN(_.offsetTop); )
      X += _.offsetLeft - _.scrollLeft, Z = U.top + _.scrollTop, _ = _.offsetParent;
    return { top: Z, left: X };
  }, L = (_, U) => {
    M.value.left = `${_ + U}px`, M.value.transform = "translateX(-100%)";
  }, T = (_) => {
    M.value.left = `${_}px`, M.value.transform = "translateX(0)";
  }, te = (_, U) => {
    e === Yt.left && T(_), e === Yt.right && L(_, U), e === Yt.center && (M.value.left = `${_ + U / 2}px`, M.value.transform = "translateX(-50%)");
  }, l = () => {
    const _ = ke(f);
    if (_) {
      const U = window.innerHeight, { top: X } = a ? O(_) : Y(_), { left: Z, width: Q, top: j, height: $ } = _.getBoundingClientRect(), D = U - j - $;
      M.value.top = j > D ? `${X - B}px` : `${X}px`, te(Z, Q);
    }
  }, o = () => {
    M.value.left = "50%", M.value.top = "50%", M.value.transform = "translate(-50%, -50%)", M.value.position = "fixed";
  }, F = (_ = !0) => {
    if (!m) {
      if (y.value)
        return o();
      const U = ke(f);
      if (a && typeof a != "boolean")
        M.value = a(U);
      else if (U) {
        const { left: X, width: Z, height: Q } = U.getBoundingClientRect(), { top: j } = a ? O(U) : Y(U);
        M.value.top = `${Q + j + +v}px`, te(X, Z), _ && n && J();
      }
    }
  }, J = () => {
    const _ = ke(f);
    if (_ && n && !m) {
      const { height: U, top: X, left: Z, width: Q } = _.getBoundingClientRect(), { top: j } = a ? O(_) : Y(_), D = window.innerHeight - X - U, u = ke(t);
      if (u) {
        const { height: s, left: k, right: E } = u.getBoundingClientRect(), ee = s + U;
        ee > X && ee > D ? X < D ? (F(!1), R.value = !1) : (M.value.top = `${j - s - +v}px`, R.value = !0) : ee > D ? (M.value.top = `${j - s - +v}px`, R.value = !0) : (F(!1), R.value = !1), k < 0 ? T(Z) : E > document.documentElement.clientWidth && L(Z, Q);
      }
    }
    h("recalculatePosition");
  };
  return { openOnTop: R, menuPosition: M, setMenuPosition: F, setInitialPosition: l, recalculatePosition: J };
}, Jr = typeof window < "u" ? window : void 0, an = () => {
}, Zr = (e) => Sa() ? (Aa(e), !0) : !1, Qr = (e, a, n, t) => {
  if (!e)
    return an;
  let f = an;
  const m = Mt(
    () => i(e),
    (y) => {
      f(), y && (y.addEventListener(a, n, t), f = () => {
        y.removeEventListener(a, n, t), f = an;
      });
    },
    { immediate: !0, flush: "post" }
  ), v = () => {
    m(), f();
  };
  return Zr(v), v;
}, xr = (e, a, n, t = {}) => {
  const { window: f = Jr, event: m = "pointerdown" } = t;
  return f ? Qr(f, m, (y) => {
    const h = ke(e), M = ke(a);
    !h || !M || h === y.target || y.composedPath().includes(h) || y.composedPath().includes(M) || n(y);
  }, { passive: !0 }) : void 0;
}, es = /* @__PURE__ */ Be({
  __name: "VueDatePicker",
  props: {
    ...Tl
  },
  emits: [
    "update:modelValue",
    "textSubmit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internalModelChange",
    "recalculatePosition",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, f = dn(), m = V(!1), v = Ct(t, "modelValue"), y = V(null), h = V(null), M = Ct(t, "teleportCenter");
    dt(vn, t.autoApply);
    const R = C(() => t.formatLocale);
    dt(Zn, R), dt(Jn, Ct(t, "textInput")), dt(Xe, Ct(t, "arrowNavigation")), Oe(() => {
      J(t.modelValue), t.inline || (window.addEventListener("scroll", P), window.addEventListener("resize", N)), t.inline && (m.value = !0);
    }), un(() => {
      t.inline || (window.removeEventListener("scroll", P), window.removeEventListener("resize", N));
    });
    const B = at(f, "all"), Y = at(f, "input");
    Mt(
      v,
      () => {
        J(v.value);
      },
      { deep: !0 }
    );
    const { openOnTop: O, menuPosition: L, setMenuPosition: T, recalculatePosition: te, setInitialPosition: l } = qr(
      t.position,
      t.altPosition,
      t.autoPosition,
      y,
      h,
      t.inline,
      t.offset,
      M,
      n
    ), {
      internalModelValue: o,
      inputValue: F,
      parseExternalModelValue: J,
      emitModelValue: _,
      checkBeforeEmit: U,
      formatInputValue: X
    } = Xr(
      t.format,
      t.timePicker,
      t.monthPicker,
      t.range,
      t.partialRange,
      t.is24,
      t.enableTimePicker,
      t.enableSeconds,
      R,
      t.multiDates,
      t.utc,
      t.weekPicker,
      t.yearPicker,
      t.textInputOptions,
      t.modelType,
      t.modelAuto,
      n
    ), { clearArrowNav: Z } = qe(), { setMenuFocused: Q, setShiftKey: j } = ua(), $ = C(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: t.inline,
        dp__flex_display_with_input: t.inlineWithInput
      })
    ), D = C(() => Vn(t.format) ? t.format : jn(
      null,
      t.is24,
      t.enableSeconds,
      t.monthPicker,
      t.timePicker,
      t.weekPicker,
      t.yearPicker,
      t.enableTimePicker
    )), u = C(() => t.previewFormat ? t.previewFormat : Vn(D.value) ? D.value : t.format), s = C(() => typeof t.transitions == "boolean" ? t.transitions ? Bn({}) : !1 : Bn(t.transitions));
    dt(Ht, s);
    const k = C(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), E = C(() => Object.assign(Jl(), t.textInputOptions)), ee = C(() => er(t.ariaLabels));
    dt(ze, ee);
    const I = C(() => Zl(t.filters)), re = C(() => {
      const c = (ne) => {
        const ce = {
          hours: Re(new Date()),
          minutes: Ve(new Date()),
          seconds: Ge(new Date())
        };
        return Object.assign(ce, ne);
      };
      return t.range ? t.startTime && Array.isArray(t.startTime) ? [c(t.startTime[0]), c(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? c(t.startTime) : null;
    }), p = C(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), P = () => {
      m.value && (t.closeOnScroll ? be() : t.autoPosition ? T() : window.removeEventListener("scroll", P));
    }, N = () => {
      m.value && T();
    }, pe = () => {
      !t.disabled && !t.readonly && (l(), m.value = !0, St().then(() => {
        T(), m.value && n("open");
      }), m.value || Ze(), J(t.modelValue));
    }, Ee = () => {
      F.value = "", Ze(), n("update:modelValue", null), n("cleared"), be();
    }, Je = () => {
      const { validate: c } = qn(
        t.minDate,
        t.maxDate,
        t.disabledDates,
        t.allowedDates,
        I.value,
        t.disabledWeekDays,
        t.yearRange
      ), ne = o.value;
      return !ne || !Array.isArray(ne) && c(ne) ? !0 : Array.isArray(ne) ? ne.length === 2 && c(ne[0]) && c(ne[1]) ? !0 : !!c(ne[0]) : !1;
    }, Ne = () => {
      U() && Je() ? (_(), be()) : n("invalid-select", o.value);
    }, We = (c) => {
      _(), t.closeOnAutoApply && !c && be();
    }, Ke = (c = !1) => {
      t.autoApply && (!t.enableTimePicker || t.monthPicker || t.yearPicker || t.ignoreTimeValidation ? !0 : on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate)) && Je() && (t.range && Array.isArray(o.value) ? (t.partialRange || o.value.length === 2) && We(c) : We(c));
    }, Ze = () => {
      o.value = null;
    }, be = () => {
      t.inline || (m.value && (m.value = !1, Q(!1), j(!1), Z(), n("closed"), l(), F.value && J(v.value)), Ze(), h.value && h.value.focusInput());
    }, ot = (c, ne) => {
      if (!c) {
        o.value = null;
        return;
      }
      o.value = c, ne && (Ne(), n("textSubmit"));
    }, pt = () => {
      t.autoApply && on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate) && _();
    }, ht = () => m.value ? be() : pe();
    return xr(y, h, be), a({
      closeMenu: be,
      selectDate: Ne,
      clearValue: Ee,
      openMenu: pe,
      onScroll: P,
      formatInputValue: X
    }), (c, ne) => (g(), S("div", {
      class: fe(i($))
    }, [
      je(Nl, Ae({
        ref_key: "inputRef",
        ref: h
      }, {
        placeholder: c.placeholder,
        hideInputIcon: c.hideInputIcon,
        readonly: c.readonly,
        disabled: c.disabled,
        inputClassName: c.inputClassName,
        clearable: c.clearable,
        state: c.state,
        inline: c.inline,
        inlineWithInput: c.inlineWithInput,
        textInput: c.textInput,
        textInputOptions: i(E),
        range: c.range,
        isMenuOpen: m.value,
        pattern: i(D),
        autoApply: c.autoApply,
        uid: c.uid,
        required: c.required,
        name: c.name,
        autocomplete: c.autocomplete
      }, {
        "input-value": i(F),
        "onUpdate:input-value": ne[0] || (ne[0] = (ce) => tt(F) ? F.value = ce : null),
        onClear: Ee,
        onOpen: pe,
        onSetInputDate: ot,
        onSetEmptyDate: i(_),
        onSelectDate: Ne,
        onToggle: ht,
        onClose: be,
        onFocus: ne[1] || (ne[1] = (ce) => c.$emit("focus")),
        onBlur: ne[2] || (ne[2] = (ce) => c.$emit("blur"))
      }), Pe({ _: 2 }, [
        ye(i(Y), (ce, it) => ({
          name: ce,
          fn: ae((Qe) => [
            W(c.$slots, ce, Le(nt(Qe)))
          ])
        }))
      ]), 1040, ["input-value", "onSetEmptyDate"]),
      m.value ? (g(), le(Pa, {
        key: 0,
        to: c.teleport,
        disabled: c.inline
      }, [
        m.value ? (g(), le(zr, Ae({
          key: 0,
          ref_key: "dpMenuRef",
          ref: y,
          class: i(k),
          style: i(L)
        }, {
          weekNumbers: c.weekNumbers,
          weekStart: c.weekStart,
          disableMonthYearSelect: c.disableMonthYearSelect,
          menuClassName: c.menuClassName,
          calendarClassName: c.calendarClassName,
          yearRange: c.yearRange,
          range: c.range,
          multiCalendars: i(p),
          multiCalendarsSolo: c.multiCalendarsSolo,
          multiStatic: c.multiStatic,
          calendarCellClassName: c.calendarCellClassName,
          enableTimePicker: c.enableTimePicker,
          is24: c.is24,
          hoursIncrement: c.hoursIncrement,
          minutesIncrement: c.minutesIncrement,
          hoursGridIncrement: c.hoursGridIncrement,
          minutesGridIncrement: c.minutesGridIncrement,
          minDate: c.minDate,
          maxDate: c.maxDate,
          autoApply: c.autoApply,
          selectText: c.selectText,
          cancelText: c.cancelText,
          previewFormat: i(u),
          locale: c.locale,
          weekNumName: c.weekNumName,
          disabledDates: c.disabledDates,
          filters: i(I),
          minTime: c.minTime,
          maxTime: c.maxTime,
          inline: c.inline,
          openOnTop: i(O),
          monthPicker: c.monthPicker,
          timePicker: c.timePicker,
          monthNameFormat: c.monthNameFormat,
          startDate: c.startDate,
          startTime: i(re),
          monthYearComponent: c.monthYearComponent,
          timePickerComponent: c.timePickerComponent,
          actionRowComponent: c.actionRowComponent,
          customProps: c.customProps,
          hideOffsetDates: c.hideOffsetDates,
          autoRange: c.autoRange,
          noToday: c.noToday,
          noHoursOverlay: c.noHoursOverlay,
          noMinutesOverlay: c.noMinutesOverlay,
          disabledWeekDays: c.disabledWeekDays,
          allowedDates: c.allowedDates,
          showNowButton: c.showNowButton,
          nowButtonLabel: c.nowButtonLabel,
          monthChangeOnScroll: c.monthChangeOnScroll,
          markers: c.markers,
          uid: c.uid,
          modeHeight: c.modeHeight,
          enableSeconds: c.enableSeconds,
          secondsIncrement: c.secondsIncrement,
          secondsGridIncrement: c.secondsGridIncrement,
          noSecondsOverlay: c.noSecondsOverlay,
          escClose: c.escClose,
          spaceConfirm: c.spaceConfirm,
          monthChangeOnArrows: c.monthChangeOnArrows,
          textInput: c.textInput,
          disabled: c.disabled,
          readonly: c.readonly,
          multiDates: c.multiDates,
          presetRanges: c.presetRanges,
          flow: c.flow,
          preventMinMaxNavigation: c.preventMinMaxNavigation,
          minRange: c.minRange,
          maxRange: c.maxRange,
          fixedStart: c.fixedStart,
          fixedEnd: c.fixedEnd,
          multiDatesLimit: c.multiDatesLimit,
          reverseYears: c.reverseYears,
          keepActionRow: c.keepActionRow,
          weekPicker: c.weekPicker,
          noSwipe: c.noSwipe,
          vertical: c.vertical,
          arrowNavigation: c.arrowNavigation,
          yearPicker: c.yearPicker,
          disableTimeRangeValidation: c.disableTimeRangeValidation,
          dayNames: c.dayNames,
          modelAuto: c.modelAuto,
          highlight: c.highlight,
          highlightWeekDays: c.highlightWeekDays,
          partialRange: c.partialRange,
          teleportCenter: c.teleportCenter,
          ignoreTimeValidation: c.ignoreTimeValidation
        }, {
          internalModelValue: i(o),
          "onUpdate:internalModelValue": ne[3] || (ne[3] = (ce) => tt(o) ? o.value = ce : null),
          onClosePicker: be,
          onSelectDate: Ne,
          onDpOpen: i(te),
          onAutoApply: Ke,
          onTimeUpdate: pt,
          onFlowStep: ne[4] || (ne[4] = (ce) => c.$emit("flow-step", ce)),
          onUpdateMonthYear: ne[5] || (ne[5] = (ce) => c.$emit("updateMonthYear", ce)),
          onInvalidSelect: ne[6] || (ne[6] = (ce) => c.$emit("invalid-select", i(o)))
        }), Pe({ _: 2 }, [
          ye(i(B), (ce, it) => ({
            name: ce,
            fn: ae((Qe) => [
              W(c.$slots, ce, Le(nt({ ...Qe })))
            ])
          }))
        ]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : b("", !0)
      ], 8, ["to", "disabled"])) : b("", !0)
    ], 2));
  }
}), da = /* @__PURE__ */ (() => {
  const e = es;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})(), ts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: da
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(ts).forEach(([e, a]) => {
  e !== "default" && (da[e] = a);
});
export {
  da as default
};
